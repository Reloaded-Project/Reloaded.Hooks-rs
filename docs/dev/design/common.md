# Common Design Notes

## Thread Safety on x86

!!! note "Thread safety is ***'theoretically'*** not guaranteed for every possible x86 processor, however is satisfied for all modern CPUs."

!!! tip "The information below is x86 specific but applies to all architectures with a non-fixed instruction size. Architectures with fixed instruction sizes (e.g. ARM) are thread safe in this library by default."

### The Theory

> If the `jmp` instruction emplaced when [switching state](./assembly-hooks/overview.md#switching-state) overwrites what originally
  were multiple instructions, it is *theoretically* possible that the placing the `jmp` will make the
  instruction about to be executed invalid.

For example if the previous instruction sequence was:

```asm
0x0: push ebp
0x1: mov ebp, esp ; 2 bytes
```

And inserting a jmp produces:

```asm
0x0: jmp disabled ; 2 bytes
```

It's possible that the CPU's Instruction Pointer was at `0x1`` at the time of the overwrite, making the
`mov ebp, esp` instruction invalid.

### What Happens in Practice

In practice, modern x86 CPUs (1990 onwards) from Intel, AMD and VIA prefetch instruction in batches 
of 16 bytes. We place our stubs generated by the various hooks on 16-byte boundaries for this 
(and optimisation) reasons.

So, by the time we change the code, the CPU has already prefetched the instructions we are atomically 
overwriting.

In other words, it is simply not possible to perfectly time a write such that a thread at `0x1` 
(`mov ebp, esp`) would read an invalid instruction, as that instruction was prefetched and is being 
executed from local thread cache.

### What is Safe

Here is a thread safety table for x86, taking the above into account:

| Safe? | Hook     | Notes                                                                                          |
| ----- | -------- | ---------------------------------------------------------------------------------------------- |
| ✅     | Function | Functions start on multiples of 16 on pretty much all compilers, per Intel Optimisation Guide. |
| ✅     | Branch   | Stubs are 16 aligned.                                                                          |
| ✅     | Assembly | Stubs are 16 aligned.                                                                          |
| ✅     | VTable   | VTable entries are `usize` aligned, and don't cross cache boundaries.                          |