{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Reloaded Hooks NextGen      Cross Platform, Cross Architecture re-implementation of Reloaded.Hooks.     \ud83e\udd80 Now in Crab \ud83e\udd80"},{"location":"#about","title":"About","text":"<p>reloaded-hooks-rs is an enhanced port of the original Reloaded.Hooks (&lt;= 4.3.0) to Rust.</p> <p>This library is written as <code>no_std</code>. Currently support for <code>Windows</code>, <code>Linux</code> and <code>macOS</code> is provided  out of the box. That said, a lot of functionality is platform &amp; architecture agnostic, hopefully making  porting easier.  </p>"},{"location":"#platform-support","title":"Platform Support","text":"Platform x86 x86_64 Windows \u2714\ufe0f \u2714\ufe0f Linux \u2714\ufe0f \u2714\ufe0f macOS N/A * \u2714\ufe0f <ul> <li>Apple dropped support for x86 platforms entirely; you can't run x86 code at all.</li> </ul> <p>The <code>reloaded-hooks-rs</code> code is not hardwired to any platform. For other platforms you can fill the [pending] struct and provide appropriate function pointers; which would possibly make the library work  even in bare metal or embedded environments.</p>"},{"location":"#architecture-support","title":"Architecture Support","text":"<p>Lists the currently available library features for different architectures.</p> Feature x86 &amp; x64 ARM64 Basic Function Hooking \u2705 \u2705 Code Relocation \u2705* \u2705 Hook Stacking \u2705 \u2705 Calling Convention Wrapper Generation \u2705 \u2705 Optimal Wrapper Generation \u2705 \u2705 Length Disassembler \u2705 \u2705 <p>Bootstrapping a new architecture is not a difficult job!! Please see Architecture Support Overview for porting guidance.</p> <ul> <li>x86 should work in all cases, but x64 isn't tested against all 5000+ instructions.</li> </ul>"},{"location":"#feature-support","title":"Feature Support","text":"<ul> <li>Supports common OSes/platforms.  </li> <li>Easy to integrate to new operating systems.  </li> <li>Calling Convention Translation (e.g. <code>__stdcall</code> -&gt; <code>__fastcall</code>).  </li> <li>Strong interoperability. (incl. Hook stacking)  </li> <li>Parameter Injection (inject a 'context' parameter to your hooks).  </li> <li>Branch rewriting.  </li> <li>Mid function x86/x64 hooks (Cheat Engine style).  </li> <li>Optimal code generation.  <ul> <li>For Relocated Code and Wrappers.  </li> <li>Improved over the common hooking libraries (Minhook, Detours), especially for ARM64.  </li> <li>(The author of this library is an anal optimization freak.) </li> </ul> </li> </ul>"},{"location":"#limitations","title":"Limitations","text":""},{"location":"#no-ip-relocation","title":"No IP Relocation","text":"<p>IP relocation is a thread safety technique employed by some libraries whereby all process' threads are stopped and any threads that are executing the prolog of the function that is being detoured at the same time have their instruction pointer overwritten to the hook.</p> <p>This can only be done on some OSes that expose the relevant APIs. For the project author's use case, this is not needed, however the project would happily accept a  PR for this functionality.  </p> <p>In practice this is very, very rarely a problem.</p>"},{"location":"#caller-saved-registers-always-saved-in-entirety","title":"Caller Saved Registers Always saved in Entirety","text":"<p>This applies to calling convention wrappers generated by the library.</p> <p>I've never seen this requirement in the wild, ever; usually for functions with this many parameters, they use standard ABI, but it's technically possible.</p> <p>When generating wrappers between different calling conventions; the library preserves entire registers, you can't for example specify 'please only preserve the upper 32-bits of register '. As is, currently only the whole register can be preserved."},{"location":"#technical-questions","title":"Technical Questions","text":"<p>If you have questions/bug reports/etc. feel free to Open an Issue.</p> <p>Happy Documenting \u2764\ufe0f</p>"},{"location":"contributing/","title":"Contribution Guidelines","text":"<p>The wiki provides details on internals of the library. They may help you when contributing \ud83d\ude09.</p> <p>First off, thank you for considering contributing to reloaded-hooks.</p> <p>If your contribution is not straightforward, please first discuss the change you wish to make by creating a new issue before making the change. We might be able to discuss general design, etc. before you embark on a huge endeavour.</p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>Before reporting an issue on the issue tracker, please check that it has not already been reported by searching for some related keywords.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>Try to do one pull request per change.  </p>"},{"location":"contributing/#commit-names","title":"Commit Names","text":"<p>Reloaded repositories auto-generate changelogs based on commit names. </p> <p>When you make git commits; try to stick to the style of Keep a changelog:</p> <ul> <li><code>Added</code> for new features.  </li> <li><code>Changed</code> for changes in existing functionality.  </li> <li><code>Deprecated</code> for soon-to-be removed features.  </li> <li><code>Removed</code> for now removed features.  </li> <li><code>Fixed</code> for any bug fixes.  </li> <li><code>Security</code> in case of vulnerabilities.  </li> </ul>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>Please use the standard code style <code>cargo fmt</code>, and run the <code>clippy</code> linter  (<code>cargo clippy</code>), fixing warnings before submitting PRs.</p> <p>If you are using VSCode, this should be automated (on Save) per this repository's settings.</p>"},{"location":"Reloaded/Readme/","title":"Readme","text":"<p>Please visit the documentation site for usage instructions &amp; more.</p>"},{"location":"Reloaded/Pages/","title":"Index","text":"The Reloaded MkDocs Theme      A Theme for MkDocs Material.          That resembles the look of Reloaded."},{"location":"Reloaded/Pages/#about","title":"About","text":"<p>This it the NexusMods theme for Material-MkDocs, inspired by the look of Reloaded-II.  </p> <p>The overall wiki theme should look fairly close to the actual launcher appearance.  </p>"},{"location":"Reloaded/Pages/#setup-from-scratch","title":"Setup From Scratch","text":"<ul> <li>Add this repository as submodule to <code>docs/Reloaded</code>.</li> <li>Save the following configuration as <code>mkdocs.yml</code> in your repository root.</li> </ul> <pre><code>site_name: Reloaded MkDocs Theme\nsite_url: https://github.com/Reloaded-Project/Reloaded.MkDocsMaterial.Themes.R2\n\nrepo_name: Reloaded-Project/Reloaded.MkDocsMaterial.Themes.R2\nrepo_url: https://github.com/Reloaded-Project/Reloaded.MkDocsMaterial.Themes.R2\n\nextra:\nsocial:\n- icon: fontawesome/brands/github\nlink: https://github.com/Reloaded-Project\n- icon: fontawesome/brands/twitter\nlink: https://twitter.com/thesewer56?lang=en-GB\n\nextra_css:\n- Reloaded/Stylesheets/extra.css\n\nmarkdown_extensions:\n- admonition\n- tables\n- pymdownx.details\n- pymdownx.highlight\n- pymdownx.superfences:\ncustom_fences:\n- name: mermaid\nclass: mermaid\nformat: !!python/name:pymdownx.superfences.fence_code_format\n- pymdownx.tasklist\n- def_list\n- meta\n- md_in_html\n- attr_list\n- footnotes\n- pymdownx.tabbed:\nalternate_style: true\n- pymdownx.emoji:\nemoji_index: !!python/name:materialx.emoji.twemoji\nemoji_generator: !!python/name:materialx.emoji.to_svg\n\ntheme:\nname: material\npalette:\nscheme: reloaded-slate\nfeatures:\n- navigation.instant\n\nplugins:\n- search\n\nnav:\n- Home: index.md\n</code></pre> <ul> <li>Add a GitHub Actions workload in <code>.github/workflows/DeployMkDocs.yml</code>.</li> </ul> <pre><code>name: DeployMkDocs\n\n# Controls when the action will run. \non:\n# Triggers the workflow on push on the master branch\npush:\nbranches: [ main ]\n\n# Allows you to run this workflow manually from the Actions tab\nworkflow_dispatch:\n\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\njobs:\n# This workflow contains a single job called \"build\"\nbuild:\n# The type of runner that the job will run on\nruns-on: ubuntu-latest\n\n# Steps represent a sequence of tasks that will be executed as part of the job\nsteps:\n\n# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it\n- name: Checkout Branch\nuses: actions/checkout@v2\nwith:\nsubmodules: recursive\n\n# Deploy MkDocs\n- name: Deploy MkDocs\n# You may pin to the exact commit or the version.\n# uses: mhausenblas/mkdocs-deploy-gh-pages@66340182cb2a1a63f8a3783e3e2146b7d151a0bb\nuses: mhausenblas/mkdocs-deploy-gh-pages@master\nenv:\nGITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\nREQUIREMENTS: ./docs/requirements.txt\n</code></pre> <ul> <li>Push to GitHub, this should produce a GitHub Pages site.  </li> <li>Go to <code>Settings -&gt; Pages</code> in your repo and select <code>gh-pages</code> branch to enable GitHub pages. </li> </ul> <p>Your page should then be live.</p> <p>Tip</p> <p>Refer to Contributing for instructions on how to locally edit and modify the wiki.</p> <p>Note</p> <p>For Reloaded3 theme use <code>reloaded3-slate</code> instead of <code>reloaded-slate</code>.</p>"},{"location":"Reloaded/Pages/#extra","title":"Extra","text":"<p>Info</p> <p>Most documentation pages will also include additional plugins; some which are used in the pages here. Here is a sample complete mkdocs.yml you can copy to your project for reference.  </p>"},{"location":"Reloaded/Pages/#technical-questions","title":"Technical Questions","text":"<p>If you have questions/bug reports/etc. feel free to Open an Issue.</p> <p>Happy Documenting \u2764\ufe0f</p>"},{"location":"Reloaded/Pages/contributing/","title":"Contributing to the Wiki: Locally","text":"<p>Info</p> <p>This page shows you how to contribute to any documentation page or wiki  based on this template.</p> <p>Note</p> <p>This theme is forked from my theme for Nexus Docs; and this page is synced with that.</p>"},{"location":"Reloaded/Pages/contributing/#tutorial","title":"Tutorial","text":"<p>Note</p> <p>If you are editing the repository with the theme itself on Windows, it might be a good idea to run <code>git config core.symlinks true</code> first to allow git to create symlinks on clone.</p> <p>You should learn the basics of <code>git</code>, an easy way is to give GitHub Desktop (Tutorial) a go. It's only 15 minutes \ud83d\ude00.</p> <ol> <li>Create a GitHub account.</li> <li> <p>Fork this repository:</p> <p></p> <p>This will create a copy of the repository on your own user account, which you will be able to edit.</p> </li> <li> <p>Clone this repository.</p> <p>For example, using GitHub Desktop: </p> </li> <li> <p>Make changes inside the <code>docs</code> folder.</p> <p></p> <p>Consider using a Markdown Cheat Sheet if you are new to markdown.</p> <p>I recommend using a markdown editor such as <code>Typora</code>. Personally I just work from inside <code>Rider</code>.  </p> </li> <li> <p>Commit the changes and push to GitHub.</p> </li> <li> <p>Open a <code>Pull Request</code>.</p> <p></p> <p>Opening a <code>Pull Request</code> will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository.</p> </li> </ol>"},{"location":"Reloaded/Pages/contributing/#website-live-preview","title":"Website Live Preview","text":"<p>If you are working on the wiki locally, you can generate a live preview the full website. Here's a quick guide of how you could do it from your <code>command prompt</code> (cmd).</p> <ol> <li> <p>Install Python 3</p> <p>If you have <code>winget</code> installed, or Windows 11, you can do this from the command prompt.</p> Windows (winget)Archlinux <pre><code>winget install Python.Python.3\n</code></pre> <pre><code>pacman -S python-pip # you should already have Python\n</code></pre> <p>Otherwise download Python 3 from the official website or package manager.</p> </li> <li> <p>Install Material for MkDocs and Plugins (Python package)</p> Windows/OSXLinux <pre><code># Restart your command prompt before running this command.\npip install mkdocs-material\npip install mkdocs-redirects\n</code></pre> <p>On Linux, there is a chance that <code>python</code> might be a core part of your OS, meaning that you ideally shouldn't touch the system installation.</p> <p>Use virtual environments instead.</p> <pre><code>python -m venv mkdocs # Create the environment\nsource ~/mkdocs/bin/activate # Enter the environment\n\npip install mkdocs-material\npip install mkdocs-redirects\n</code></pre> <p>Make sure you enter the environment before any time you run mkdocs.</p> </li> <li> <p>Open a command prompt in the folder containing <code>mkdocs.yml</code>. and run the site locally.     <pre><code># Move to project folder.\ncd &lt;Replace this with full path to folder containing `mkdocs.yml`&gt;\nmkdocs serve\n</code></pre></p> <p></p> <p>Copy the address to your web browser and enjoy the live preview; any changes you save will be shown instantly.</p> </li> </ol>"},{"location":"Reloaded/Pages/license/","title":"The Reloaded Project License","text":"<p>Most components of the Reloaded are governed by the GPLv3 license.</p> <p>In some, albeit rare scenarios, certain libraries might be licensed under LGPLv3 instead.</p> <p>This is a FAQ meant to clarify the licensing choice and its implications. Please note, though, that the full license text is the final legal authority.</p>"},{"location":"Reloaded/Pages/license/#why-was-gpl-v3-chosen","title":"Why was GPL v3 chosen?","text":"<p>The primary objective is to prevent closed-source, commercial exploitation of the project.</p> <p>We want to ensure that the project isn't used within a proprietary environment for profit-making purposes such as:</p> <ul> <li>Being sold behind a Patreon paywall.</li> <li>Being integrated into a closed-source commercial product for sale.</li> </ul> <p>The Reloaded Project is a labour of love from unpaid hobbyist volunteers.</p> <p>Exploiting that work for profit feels fundamentally unfair.</p> <p>While the GPLv3 license doesn't prohibit commercial use outright, it does prevent commercial exploitation by requiring that contributions are given back to the open-source community.</p> <p>In that fashion, everyone can benefit from the projects under the Reloaded label.</p>"},{"location":"Reloaded/Pages/license/#can-i-use-reloaded-libraries-commercially","title":"Can I use Reloaded Libraries Commercially?","text":"<p>You can as long as the resulting produce is also licensed under GPLv3, and thus open source.</p>"},{"location":"Reloaded/Pages/license/#can-i-use-reloaded-libraries-in-a-closed-source-application","title":"Can I use Reloaded Libraries in a closed-source application?","text":"<p>The license terms do not permit this.</p> <p>However, if your software is completely non-commercial, meaning it's neither sold for profit, funded in development, nor hidden behind a paywall (like Patreon), we probably just look the other way.</p> <p>This often applies to non-professional programmers, learners, or those with no intent to exploit the project. We believe in understanding and leniency for those who might not know better.</p> <p>GPL v3 exists to protect the project and its contributors. If you're not exploiting the project for commercial  gain, you're not hurting us; and we will not enforce the terms of the GPL.</p> <p>If you are interested in obtaining a commercial license, or want an explicit written exemption,  please get in touch with the repository owners.</p>"},{"location":"Reloaded/Pages/license/#can-i-link-reloaded-libraries-staticallydynamically","title":"Can I link Reloaded Libraries statically/dynamically?","text":"<p>Yes, as long as you adhere to the GPLv3 license terms, you're permitted to statically link Reloaded Libraries into your project, for instance, through the use of NativeAOT or ILMerge.</p>"},{"location":"Reloaded/Pages/license/#guidelines-for-non-commercial-use","title":"Guidelines for Non-Commercial Use","text":"<p>We support and encourage the non-commercial use of Reloaded Libraries. Non-commercial use generally refers to the usage of our libraries for personal projects, educational purposes, academic research, or use by non-profit organizations.</p>"},{"location":"Reloaded/Pages/license/#personal-projects","title":"Personal Projects","text":"<p>You're free to use our libraries for projects that you undertake for your own learning, hobby or personal enjoyment. This includes creating mods for your favorite games or building your own applications for personal use.</p>"},{"location":"Reloaded/Pages/license/#educational-use","title":"Educational Use","text":"<p>Teachers and students are welcome to use our libraries as a learning resource. You can incorporate them into your teaching materials, student projects, coding bootcamps, workshops, etc.</p>"},{"location":"Reloaded/Pages/license/#academic-research","title":"Academic Research","text":"<p>Researchers may use our libraries for academic and scholarly research. We'd appreciate if you cite our work in any publications that result from research involving our libraries.</p>"},{"location":"Reloaded/Pages/license/#non-profit-organizations","title":"Non-profit Organizations","text":"<p>If you're part of a registered non-profit organization, you can use our libraries in your projects. However, any derivative work that uses our libraries must also be released under the GPL.</p> <p>Please remember, if your usage of our libraries evolves from non-commercial to commercial, you must ensure compliance with the terms of the GPL v3 license.</p>"},{"location":"Reloaded/Pages/license/#attribution-requirements","title":"Attribution Requirements","text":"<p>As Reloaded Project is a labor of love, done purely out of passion and with an aim to contribute to the broader community, we highly appreciate your support in providing attribution when using our libraries.  </p> <p>While not legally mandatory under GPL v3, it is a simple act that can go a long way in recognizing the efforts of our contributors and fostering an open and collaborative atmosphere.</p> <p>If you choose to provide attribution (and we hope you do!), here are some guidelines:</p> <ul> <li> <p>Acknowledge the Use of Reloaded Libraries: Mention that your project uses or is based on Reloaded libraries.   This could be in your project's readme, a credits page on a website, a manual, or within the software itself.</p> </li> <li> <p>Link to the Project: If possible, provide a link back to the Reloaded Project.   This allows others to explore and potentially benefit from our work.</p> </li> </ul> <p>Remember, attribution is more than just giving credit,,, it's a way of saying thank you \ud83d\udc49\ud83d\udc48, fostering reciprocal respect, and acknowledging the power of collaborative open-source development.</p> <p>We appreciate your support and look forward to seeing what amazing projects you create using Reloaded libraries!</p>"},{"location":"Reloaded/Pages/license/#code-from-mitbsd-licensed-projects","title":"Code from MIT/BSD Licensed Projects","text":"<p>In some rare instances, code from more permissively licensed projects, such as those under the <code>MIT</code> or <code>BSD</code> licenses, may be referenced, incorporated, or slightly modified within the Reloaded Project.</p> <p>It's important to us to respect the terms and intentions of these permissive licenses, which often allow their code to be used in a wide variety of contexts, including in GPL-licensed projects like ours.</p> <p>In these cases, the Reloaded Project is committed to clearly disclosing the usage of such code:</p> <ul> <li> <p>Method-Level Disclosure: For individual methods or small code snippets, we use appropriate   attribution methods, like programming language attributes. For example, methods borrowed or adapted   from MIT-licensed projects might be marked with a <code>[MITLicense]</code> attribute.</p> </li> <li> <p>File-Level Disclosure: For larger amounts of code, such as entire files or modules, we'll include   the original license text at the top of the file and clearly indicate which portions of the code originate   from a differently-licensed project.</p> </li> <li> <p>Project-Level Disclosure: If an entire library or significant portion of a project under a more permissive   license is used, we will include an acknowledgment in a prominent location, such as the readme file or the   project's license documentation.</p> </li> </ul> <p>This approach ensures we honor the contributions of the open source community at large, respect the original licenses, and maintain transparency with our users about where code originates from.</p> <p>Any files/methods or snippets marked with those attributes may be consumed using their original license terms.  </p> <p>i.e. If a method is marked with <code>[MITLicense]</code>, you may use it under the terms of the MIT license.  </p>"},{"location":"Reloaded/Pages/license/#contributing-to-the-reloaded-project","title":"Contributing to the Reloaded Project","text":"<p>We welcome and appreciate contributions to the Reloaded Project! By contributing, you agree to share your changes under the same GPLv3 license, helping to make the project better for everyone.</p>"},{"location":"Reloaded/Pages/testing-zone/","title":"Testing Zone","text":"<p>Info</p> <p>This is a dummy page with various Material MkDocs controls and features scattered throughout for testing.</p>"},{"location":"Reloaded/Pages/testing-zone/#custom-admonitions","title":"Custom Admonitions","text":"<p>Reloaded Admonition</p> <p>An admonition featuring a Reloaded logo. My source is in Stylesheets/extra.css as <code>Custom 'reloaded' admonition</code>.  </p> <p>Heart Admonition</p> <p>An admonition featuring a heart; because we want to contribute back to the open source community. My source is in Stylesheets/extra.css as <code>Custom 'reloaded heart' admonition</code>.</p> <p>Nexus Admonition</p> <p>An admonition featuring a Nexus logo. My source is in Stylesheets/extra.css as <code>Custom 'nexus' admonition</code>.  </p> <p>Heart Admonition</p> <p>An admonition featuring a heart; because we want to contribute back to the open source community. My source is in Stylesheets/extra.css as <code>Custom 'nexus heart' admonition</code>.  </p>"},{"location":"Reloaded/Pages/testing-zone/#mermaid-diagram","title":"Mermaid Diagram","text":"<p>Flowchart (Source: Nexus Archive Library):  </p> <pre><code>flowchart TD\n    subgraph Block 2\n        BigFile1.bin\n    end\n\n    subgraph Block 1\n        BigFile0.bin\n    end\n\n    subgraph Block 0\n        ModConfig.json -.-&gt; Updates.json \n        Updates.json -.-&gt; more[\"... more .json files\"]        \n    end</code></pre> <p>Sequence Diagram (Source: Reloaded3 Specification):  </p> <pre><code>sequenceDiagram\n\n    % Define Items\n    participant Mod Loader\n    participant Virtual FileSystem (VFS)\n    participant CRI CPK Archive Support\n    participant Persona 5 Royal Support\n    participant Joker Costume\n\n    % Define Actions\n    Mod Loader-&gt;&gt;Persona 5 Royal Support: Load Mod\n    Persona 5 Royal Support-&gt;&gt;Mod Loader: Request CRI CPK Archive Support API\n    Mod Loader-&gt;&gt;Persona 5 Royal Support: Receive CRI CPK Archive Support Instance\n\n    Mod Loader-&gt;&gt;Joker Costume: Load Mod\n    Mod Loader--&gt;Persona 5 Royal Support: Notification: 'Loaded Joker Costume'\n    Persona 5 Royal Support-&gt;&gt;CRI CPK Archive Support: Add Files from 'Joker Costume' to CPK Archive (via API)</code></pre> <p>State Diagram (Source: Mermaid Docs):  </p> <pre><code>stateDiagram-v2\n    [*] --&gt; Still\n    Still --&gt; [*]\n\n    Still --&gt; Moving\n    Moving --&gt; Still\n    Moving --&gt; Crash\n    Crash --&gt; [*]</code></pre> <p>Class Diagram (Arbitrary)</p> <pre><code>classDiagram\n    class Animal\n    `NexusMobile\u2122` &lt;|-- Car</code></pre> <p>Note</p> <p>At time of writing, version of Mermaid is a bit outdated here; and other diagrams might not render correctly (even on unmodified theme); thus certain diagrams have been omitted from here.</p>"},{"location":"Reloaded/Pages/testing-zone/#code-block","title":"Code Block","text":"<p>Snippet from C# version of Sewer's Virtual FileSystem (VFS):</p> <pre><code>/// &lt;summary&gt;\n/// Tries to get files for a specific folder, assuming the input path is already in upper case.\n/// &lt;/summary&gt;\n/// &lt;param name=\"folderPath\"&gt;The folder to find. Already lowercase.&lt;/param&gt;\n/// &lt;param name=\"value\"&gt;The returned folder instance.&lt;/param&gt;\n/// &lt;returns&gt;True if found, else false.&lt;/returns&gt;\n[MethodImpl(MethodImplOptions.AggressiveInlining)]\npublic bool TryGetFolderUpper(ReadOnlySpan&lt;char&gt; folderPath, out SpanOfCharDict&lt;TTarget&gt; value)\n{\n// Must be O(1)\nvalue = default!;        // Compare equality.\n// Note to devs: Do not invert branches, we optimise for hot paths here.\nif (folderPath.StartsWith(Prefix))\n{\n// Check for subfolder in branchless way.\n// In CLR, bool is length 1, so conversion to byte should be safe.\n// Even suppose it is not; as long as code is little endian; truncating int/4 bytes to byte still results \n// in correct answer.\nvar hasSubfolder = Prefix.Length != folderPath.Length;\nvar hasSubfolderByte = Unsafe.As&lt;bool, byte&gt;(ref hasSubfolder);\nvar nextFolder = folderPath.SliceFast(Prefix.Length + hasSubfolderByte);\n\nreturn SubfolderToFiles.TryGetValue(nextFolder, out value!);\n}\n\nreturn false;\n}\n</code></pre> <p>Something more number heavy, Fast Inverse Square Root from Quake III Arena (unmodified). <pre><code>float Q_rsqrt( float number )\n{\nlong i;\nfloat x2, y;\nconst float threehalfs = 1.5F;\n\nx2 = number * 0.5F;\ny  = number;\ni  = * ( long * ) &amp;y;                       // evil floating point bit level hacking\ni  = 0x5f3759df - ( i &gt;&gt; 1 );               // what the fuck? \ny  = * ( float * ) &amp;i;\ny  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration\n//  y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed\n\nreturn y;\n}\n</code></pre></p>"},{"location":"Reloaded/Pages/testing-zone/#default-admonitions","title":"Default Admonitions","text":"<p>Note</p> <p>Test</p> <p>Abstract</p> <p>Test</p> <p>Info</p> <p>Test</p> <p>Tip</p> <p>Test</p> <p>Success</p> <p>Test</p> <p>Question</p> <p>Test</p> <p>Warning</p> <p>Test</p> <p>Failure</p> <p>Test</p> <p>Danger</p> <p>Test</p> <p>Bug</p> <p>Test</p> <p>Example</p> <p>Test</p> <p>Quote</p> <p>Test</p>"},{"location":"Reloaded/Pages/testing-zone/#tables","title":"Tables","text":"Method Description <code>GET</code>      Fetch resource <code>PUT</code>  Update resource <code>DELETE</code>      Delete resource"},{"location":"Reloaded/docs/Pages/","title":"Index","text":"The Reloaded MkDocs Theme      A Theme for MkDocs Material.          That resembles the look of Reloaded."},{"location":"Reloaded/docs/Pages/#about","title":"About","text":"<p>This it the NexusMods theme for Material-MkDocs, inspired by the look of Reloaded-II.  </p> <p>The overall wiki theme should look fairly close to the actual launcher appearance.  </p>"},{"location":"Reloaded/docs/Pages/#setup-from-scratch","title":"Setup From Scratch","text":"<ul> <li>Add this repository as submodule to <code>docs/Reloaded</code>.</li> <li>Save the following configuration as <code>mkdocs.yml</code> in your repository root.</li> </ul> <pre><code>site_name: Reloaded MkDocs Theme\nsite_url: https://github.com/Reloaded-Project/Reloaded.MkDocsMaterial.Themes.R2\n\nrepo_name: Reloaded-Project/Reloaded.MkDocsMaterial.Themes.R2\nrepo_url: https://github.com/Reloaded-Project/Reloaded.MkDocsMaterial.Themes.R2\n\nextra:\nsocial:\n- icon: fontawesome/brands/github\nlink: https://github.com/Reloaded-Project\n- icon: fontawesome/brands/twitter\nlink: https://twitter.com/thesewer56?lang=en-GB\n\nextra_css:\n- Reloaded/Stylesheets/extra.css\n\nmarkdown_extensions:\n- admonition\n- tables\n- pymdownx.details\n- pymdownx.highlight\n- pymdownx.superfences:\ncustom_fences:\n- name: mermaid\nclass: mermaid\nformat: !!python/name:pymdownx.superfences.fence_code_format\n- pymdownx.tasklist\n- def_list\n- meta\n- md_in_html\n- attr_list\n- footnotes\n- pymdownx.tabbed:\nalternate_style: true\n- pymdownx.emoji:\nemoji_index: !!python/name:materialx.emoji.twemoji\nemoji_generator: !!python/name:materialx.emoji.to_svg\n\ntheme:\nname: material\npalette:\nscheme: reloaded-slate\nfeatures:\n- navigation.instant\n\nplugins:\n- search\n\nnav:\n- Home: index.md\n</code></pre> <ul> <li>Add a GitHub Actions workload in <code>.github/workflows/DeployMkDocs.yml</code>.</li> </ul> <pre><code>name: DeployMkDocs\n\n# Controls when the action will run. \non:\n# Triggers the workflow on push on the master branch\npush:\nbranches: [ main ]\n\n# Allows you to run this workflow manually from the Actions tab\nworkflow_dispatch:\n\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\njobs:\n# This workflow contains a single job called \"build\"\nbuild:\n# The type of runner that the job will run on\nruns-on: ubuntu-latest\n\n# Steps represent a sequence of tasks that will be executed as part of the job\nsteps:\n\n# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it\n- name: Checkout Branch\nuses: actions/checkout@v2\nwith:\nsubmodules: recursive\n\n# Deploy MkDocs\n- name: Deploy MkDocs\n# You may pin to the exact commit or the version.\n# uses: mhausenblas/mkdocs-deploy-gh-pages@66340182cb2a1a63f8a3783e3e2146b7d151a0bb\nuses: mhausenblas/mkdocs-deploy-gh-pages@master\nenv:\nGITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\nREQUIREMENTS: ./docs/requirements.txt\n</code></pre> <ul> <li>Push to GitHub, this should produce a GitHub Pages site.  </li> <li>Go to <code>Settings -&gt; Pages</code> in your repo and select <code>gh-pages</code> branch to enable GitHub pages. </li> </ul> <p>Your page should then be live.</p> <p>Tip</p> <p>Refer to Contributing for instructions on how to locally edit and modify the wiki.</p> <p>Note</p> <p>For Reloaded3 theme use <code>reloaded3-slate</code> instead of <code>reloaded-slate</code>.</p>"},{"location":"Reloaded/docs/Pages/#extra","title":"Extra","text":"<p>Info</p> <p>Most documentation pages will also include additional plugins; some which are used in the pages here. Here is a sample complete mkdocs.yml you can copy to your project for reference.  </p>"},{"location":"Reloaded/docs/Pages/#technical-questions","title":"Technical Questions","text":"<p>If you have questions/bug reports/etc. feel free to Open an Issue.</p> <p>Happy Documenting \u2764\ufe0f</p>"},{"location":"Reloaded/docs/Pages/contributing/","title":"Contributing to the Wiki: Locally","text":"<p>Info</p> <p>This page shows you how to contribute to any documentation page or wiki  based on this template.</p> <p>Note</p> <p>This theme is forked from my theme for Nexus Docs; and this page is synced with that.</p>"},{"location":"Reloaded/docs/Pages/contributing/#tutorial","title":"Tutorial","text":"<p>Note</p> <p>If you are editing the repository with the theme itself on Windows, it might be a good idea to run <code>git config core.symlinks true</code> first to allow git to create symlinks on clone.</p> <p>You should learn the basics of <code>git</code>, an easy way is to give GitHub Desktop (Tutorial) a go. It's only 15 minutes \ud83d\ude00.</p> <ol> <li>Create a GitHub account.</li> <li> <p>Fork this repository:</p> <p></p> <p>This will create a copy of the repository on your own user account, which you will be able to edit.</p> </li> <li> <p>Clone this repository.</p> <p>For example, using GitHub Desktop: </p> </li> <li> <p>Make changes inside the <code>docs</code> folder.</p> <p></p> <p>Consider using a Markdown Cheat Sheet if you are new to markdown.</p> <p>I recommend using a markdown editor such as <code>Typora</code>. Personally I just work from inside <code>Rider</code>.  </p> </li> <li> <p>Commit the changes and push to GitHub.</p> </li> <li> <p>Open a <code>Pull Request</code>.</p> <p></p> <p>Opening a <code>Pull Request</code> will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository.</p> </li> </ol>"},{"location":"Reloaded/docs/Pages/contributing/#website-live-preview","title":"Website Live Preview","text":"<p>If you are working on the wiki locally, you can generate a live preview the full website. Here's a quick guide of how you could do it from your <code>command prompt</code> (cmd).</p> <ol> <li> <p>Install Python 3</p> <p>If you have <code>winget</code> installed, or Windows 11, you can do this from the command prompt.</p> Windows (winget)Archlinux <pre><code>winget install Python.Python.3\n</code></pre> <pre><code>pacman -S python-pip # you should already have Python\n</code></pre> <p>Otherwise download Python 3 from the official website or package manager.</p> </li> <li> <p>Install Material for MkDocs and Plugins (Python package)</p> Windows/OSXLinux <pre><code># Restart your command prompt before running this command.\npip install mkdocs-material\npip install mkdocs-redirects\n</code></pre> <p>On Linux, there is a chance that <code>python</code> might be a core part of your OS, meaning that you ideally shouldn't touch the system installation.</p> <p>Use virtual environments instead.</p> <pre><code>python -m venv mkdocs # Create the environment\nsource ~/mkdocs/bin/activate # Enter the environment\n\npip install mkdocs-material\npip install mkdocs-redirects\n</code></pre> <p>Make sure you enter the environment before any time you run mkdocs.</p> </li> <li> <p>Open a command prompt in the folder containing <code>mkdocs.yml</code>. and run the site locally.     <pre><code># Move to project folder.\ncd &lt;Replace this with full path to folder containing `mkdocs.yml`&gt;\nmkdocs serve\n</code></pre></p> <p></p> <p>Copy the address to your web browser and enjoy the live preview; any changes you save will be shown instantly.</p> </li> </ol>"},{"location":"Reloaded/docs/Pages/license/","title":"The Reloaded Project License","text":"<p>Most components of the Reloaded are governed by the GPLv3 license.</p> <p>In some, albeit rare scenarios, certain libraries might be licensed under LGPLv3 instead.</p> <p>This is a FAQ meant to clarify the licensing choice and its implications. Please note, though, that the full license text is the final legal authority.</p>"},{"location":"Reloaded/docs/Pages/license/#why-was-gpl-v3-chosen","title":"Why was GPL v3 chosen?","text":"<p>The primary objective is to prevent closed-source, commercial exploitation of the project.</p> <p>We want to ensure that the project isn't used within a proprietary environment for profit-making purposes such as:</p> <ul> <li>Being sold behind a Patreon paywall.</li> <li>Being integrated into a closed-source commercial product for sale.</li> </ul> <p>The Reloaded Project is a labour of love from unpaid hobbyist volunteers.</p> <p>Exploiting that work for profit feels fundamentally unfair.</p> <p>While the GPLv3 license doesn't prohibit commercial use outright, it does prevent commercial exploitation by requiring that contributions are given back to the open-source community.</p> <p>In that fashion, everyone can benefit from the projects under the Reloaded label.</p>"},{"location":"Reloaded/docs/Pages/license/#can-i-use-reloaded-libraries-commercially","title":"Can I use Reloaded Libraries Commercially?","text":"<p>You can as long as the resulting produce is also licensed under GPLv3, and thus open source.</p>"},{"location":"Reloaded/docs/Pages/license/#can-i-use-reloaded-libraries-in-a-closed-source-application","title":"Can I use Reloaded Libraries in a closed-source application?","text":"<p>The license terms do not permit this.</p> <p>However, if your software is completely non-commercial, meaning it's neither sold for profit, funded in development, nor hidden behind a paywall (like Patreon), we probably just look the other way.</p> <p>This often applies to non-professional programmers, learners, or those with no intent to exploit the project. We believe in understanding and leniency for those who might not know better.</p> <p>GPL v3 exists to protect the project and its contributors. If you're not exploiting the project for commercial  gain, you're not hurting us; and we will not enforce the terms of the GPL.</p> <p>If you are interested in obtaining a commercial license, or want an explicit written exemption,  please get in touch with the repository owners.</p>"},{"location":"Reloaded/docs/Pages/license/#can-i-link-reloaded-libraries-staticallydynamically","title":"Can I link Reloaded Libraries statically/dynamically?","text":"<p>Yes, as long as you adhere to the GPLv3 license terms, you're permitted to statically link Reloaded Libraries into your project, for instance, through the use of NativeAOT or ILMerge.</p>"},{"location":"Reloaded/docs/Pages/license/#guidelines-for-non-commercial-use","title":"Guidelines for Non-Commercial Use","text":"<p>We support and encourage the non-commercial use of Reloaded Libraries. Non-commercial use generally refers to the usage of our libraries for personal projects, educational purposes, academic research, or use by non-profit organizations.</p>"},{"location":"Reloaded/docs/Pages/license/#personal-projects","title":"Personal Projects","text":"<p>You're free to use our libraries for projects that you undertake for your own learning, hobby or personal enjoyment. This includes creating mods for your favorite games or building your own applications for personal use.</p>"},{"location":"Reloaded/docs/Pages/license/#educational-use","title":"Educational Use","text":"<p>Teachers and students are welcome to use our libraries as a learning resource. You can incorporate them into your teaching materials, student projects, coding bootcamps, workshops, etc.</p>"},{"location":"Reloaded/docs/Pages/license/#academic-research","title":"Academic Research","text":"<p>Researchers may use our libraries for academic and scholarly research. We'd appreciate if you cite our work in any publications that result from research involving our libraries.</p>"},{"location":"Reloaded/docs/Pages/license/#non-profit-organizations","title":"Non-profit Organizations","text":"<p>If you're part of a registered non-profit organization, you can use our libraries in your projects. However, any derivative work that uses our libraries must also be released under the GPL.</p> <p>Please remember, if your usage of our libraries evolves from non-commercial to commercial, you must ensure compliance with the terms of the GPL v3 license.</p>"},{"location":"Reloaded/docs/Pages/license/#attribution-requirements","title":"Attribution Requirements","text":"<p>As Reloaded Project is a labor of love, done purely out of passion and with an aim to contribute to the broader community, we highly appreciate your support in providing attribution when using our libraries.  </p> <p>While not legally mandatory under GPL v3, it is a simple act that can go a long way in recognizing the efforts of our contributors and fostering an open and collaborative atmosphere.</p> <p>If you choose to provide attribution (and we hope you do!), here are some guidelines:</p> <ul> <li> <p>Acknowledge the Use of Reloaded Libraries: Mention that your project uses or is based on Reloaded libraries.   This could be in your project's readme, a credits page on a website, a manual, or within the software itself.</p> </li> <li> <p>Link to the Project: If possible, provide a link back to the Reloaded Project.   This allows others to explore and potentially benefit from our work.</p> </li> </ul> <p>Remember, attribution is more than just giving credit,,, it's a way of saying thank you \ud83d\udc49\ud83d\udc48, fostering reciprocal respect, and acknowledging the power of collaborative open-source development.</p> <p>We appreciate your support and look forward to seeing what amazing projects you create using Reloaded libraries!</p>"},{"location":"Reloaded/docs/Pages/license/#code-from-mitbsd-licensed-projects","title":"Code from MIT/BSD Licensed Projects","text":"<p>In some rare instances, code from more permissively licensed projects, such as those under the <code>MIT</code> or <code>BSD</code> licenses, may be referenced, incorporated, or slightly modified within the Reloaded Project.</p> <p>It's important to us to respect the terms and intentions of these permissive licenses, which often allow their code to be used in a wide variety of contexts, including in GPL-licensed projects like ours.</p> <p>In these cases, the Reloaded Project is committed to clearly disclosing the usage of such code:</p> <ul> <li> <p>Method-Level Disclosure: For individual methods or small code snippets, we use appropriate   attribution methods, like programming language attributes. For example, methods borrowed or adapted   from MIT-licensed projects might be marked with a <code>[MITLicense]</code> attribute.</p> </li> <li> <p>File-Level Disclosure: For larger amounts of code, such as entire files or modules, we'll include   the original license text at the top of the file and clearly indicate which portions of the code originate   from a differently-licensed project.</p> </li> <li> <p>Project-Level Disclosure: If an entire library or significant portion of a project under a more permissive   license is used, we will include an acknowledgment in a prominent location, such as the readme file or the   project's license documentation.</p> </li> </ul> <p>This approach ensures we honor the contributions of the open source community at large, respect the original licenses, and maintain transparency with our users about where code originates from.</p> <p>Any files/methods or snippets marked with those attributes may be consumed using their original license terms.  </p> <p>i.e. If a method is marked with <code>[MITLicense]</code>, you may use it under the terms of the MIT license.  </p>"},{"location":"Reloaded/docs/Pages/license/#contributing-to-the-reloaded-project","title":"Contributing to the Reloaded Project","text":"<p>We welcome and appreciate contributions to the Reloaded Project! By contributing, you agree to share your changes under the same GPLv3 license, helping to make the project better for everyone.</p>"},{"location":"Reloaded/docs/Pages/testing-zone/","title":"Testing Zone","text":"<p>Info</p> <p>This is a dummy page with various Material MkDocs controls and features scattered throughout for testing.</p>"},{"location":"Reloaded/docs/Pages/testing-zone/#custom-admonitions","title":"Custom Admonitions","text":"<p>Reloaded Admonition</p> <p>An admonition featuring a Reloaded logo. My source is in Stylesheets/extra.css as <code>Custom 'reloaded' admonition</code>.  </p> <p>Heart Admonition</p> <p>An admonition featuring a heart; because we want to contribute back to the open source community. My source is in Stylesheets/extra.css as <code>Custom 'reloaded heart' admonition</code>.</p> <p>Nexus Admonition</p> <p>An admonition featuring a Nexus logo. My source is in Stylesheets/extra.css as <code>Custom 'nexus' admonition</code>.  </p> <p>Heart Admonition</p> <p>An admonition featuring a heart; because we want to contribute back to the open source community. My source is in Stylesheets/extra.css as <code>Custom 'nexus heart' admonition</code>.  </p>"},{"location":"Reloaded/docs/Pages/testing-zone/#mermaid-diagram","title":"Mermaid Diagram","text":"<p>Flowchart (Source: Nexus Archive Library):  </p> <pre><code>flowchart TD\n    subgraph Block 2\n        BigFile1.bin\n    end\n\n    subgraph Block 1\n        BigFile0.bin\n    end\n\n    subgraph Block 0\n        ModConfig.json -.-&gt; Updates.json \n        Updates.json -.-&gt; more[\"... more .json files\"]        \n    end</code></pre> <p>Sequence Diagram (Source: Reloaded3 Specification):  </p> <pre><code>sequenceDiagram\n\n    % Define Items\n    participant Mod Loader\n    participant Virtual FileSystem (VFS)\n    participant CRI CPK Archive Support\n    participant Persona 5 Royal Support\n    participant Joker Costume\n\n    % Define Actions\n    Mod Loader-&gt;&gt;Persona 5 Royal Support: Load Mod\n    Persona 5 Royal Support-&gt;&gt;Mod Loader: Request CRI CPK Archive Support API\n    Mod Loader-&gt;&gt;Persona 5 Royal Support: Receive CRI CPK Archive Support Instance\n\n    Mod Loader-&gt;&gt;Joker Costume: Load Mod\n    Mod Loader--&gt;Persona 5 Royal Support: Notification: 'Loaded Joker Costume'\n    Persona 5 Royal Support-&gt;&gt;CRI CPK Archive Support: Add Files from 'Joker Costume' to CPK Archive (via API)</code></pre> <p>State Diagram (Source: Mermaid Docs):  </p> <pre><code>stateDiagram-v2\n    [*] --&gt; Still\n    Still --&gt; [*]\n\n    Still --&gt; Moving\n    Moving --&gt; Still\n    Moving --&gt; Crash\n    Crash --&gt; [*]</code></pre> <p>Class Diagram (Arbitrary)</p> <pre><code>classDiagram\n    class Animal\n    `NexusMobile\u2122` &lt;|-- Car</code></pre> <p>Note</p> <p>At time of writing, version of Mermaid is a bit outdated here; and other diagrams might not render correctly (even on unmodified theme); thus certain diagrams have been omitted from here.</p>"},{"location":"Reloaded/docs/Pages/testing-zone/#code-block","title":"Code Block","text":"<p>Snippet from C# version of Sewer's Virtual FileSystem (VFS):</p> <pre><code>/// &lt;summary&gt;\n/// Tries to get files for a specific folder, assuming the input path is already in upper case.\n/// &lt;/summary&gt;\n/// &lt;param name=\"folderPath\"&gt;The folder to find. Already lowercase.&lt;/param&gt;\n/// &lt;param name=\"value\"&gt;The returned folder instance.&lt;/param&gt;\n/// &lt;returns&gt;True if found, else false.&lt;/returns&gt;\n[MethodImpl(MethodImplOptions.AggressiveInlining)]\npublic bool TryGetFolderUpper(ReadOnlySpan&lt;char&gt; folderPath, out SpanOfCharDict&lt;TTarget&gt; value)\n{\n// Must be O(1)\nvalue = default!;        // Compare equality.\n// Note to devs: Do not invert branches, we optimise for hot paths here.\nif (folderPath.StartsWith(Prefix))\n{\n// Check for subfolder in branchless way.\n// In CLR, bool is length 1, so conversion to byte should be safe.\n// Even suppose it is not; as long as code is little endian; truncating int/4 bytes to byte still results \n// in correct answer.\nvar hasSubfolder = Prefix.Length != folderPath.Length;\nvar hasSubfolderByte = Unsafe.As&lt;bool, byte&gt;(ref hasSubfolder);\nvar nextFolder = folderPath.SliceFast(Prefix.Length + hasSubfolderByte);\n\nreturn SubfolderToFiles.TryGetValue(nextFolder, out value!);\n}\n\nreturn false;\n}\n</code></pre> <p>Something more number heavy, Fast Inverse Square Root from Quake III Arena (unmodified). <pre><code>float Q_rsqrt( float number )\n{\nlong i;\nfloat x2, y;\nconst float threehalfs = 1.5F;\n\nx2 = number * 0.5F;\ny  = number;\ni  = * ( long * ) &amp;y;                       // evil floating point bit level hacking\ni  = 0x5f3759df - ( i &gt;&gt; 1 );               // what the fuck? \ny  = * ( float * ) &amp;i;\ny  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration\n//  y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed\n\nreturn y;\n}\n</code></pre></p>"},{"location":"Reloaded/docs/Pages/testing-zone/#default-admonitions","title":"Default Admonitions","text":"<p>Note</p> <p>Test</p> <p>Abstract</p> <p>Test</p> <p>Info</p> <p>Test</p> <p>Tip</p> <p>Test</p> <p>Success</p> <p>Test</p> <p>Question</p> <p>Test</p> <p>Warning</p> <p>Test</p> <p>Failure</p> <p>Test</p> <p>Danger</p> <p>Test</p> <p>Bug</p> <p>Test</p> <p>Example</p> <p>Test</p> <p>Quote</p> <p>Test</p>"},{"location":"Reloaded/docs/Pages/testing-zone/#tables","title":"Tables","text":"Method Description <code>GET</code>      Fetch resource <code>PUT</code>  Update resource <code>DELETE</code>      Delete resource"},{"location":"dev/arch/operations-impl/","title":"Operations","text":"<p>This page tells you which Operations are currently implemented for each architecture.</p> <ul> <li>\u274c Means it is not implemented.</li> <li>\u2705 Means it is implemented.</li> <li>\u2753 Means 'not applicable'.</li> </ul>"},{"location":"dev/arch/operations-impl/#needed-for-basic-hooking-support","title":"Needed for Basic Hooking Support","text":""},{"location":"dev/arch/operations-impl/#jumprelative","title":"JumpRelative","text":"Architecture Supported Notes x64 \u2705 +-2GiB x86 \u2705 +-2GiB ARM64 (+- 128MiB) \u2705 +-128MiB ARM64 (+- 4GiB) \u2705 Uses 3 instructions. Used if within range."},{"location":"dev/arch/operations-impl/#jumpabsolute","title":"JumpAbsolute","text":"Architecture Supported Notes x64 \u2705 Uses scratch register for efficiency. x86 \u2705 Uses scratch register for efficiency. ARM64 \u2705 Uses scratch register (required)"},{"location":"dev/arch/operations-impl/#jumpabsoluteindirect","title":"JumpAbsoluteIndirect","text":"Architecture Supported Notes x86 \u2705 x86 \u2705 ARM64 \u274c Variant 0. ARM64 \u2705 Variant 1. Replaced with JumpAbsolute, for perf reasons."},{"location":"dev/arch/operations-impl/#needed-for-wrapper-generation","title":"Needed for Wrapper Generation","text":""},{"location":"dev/arch/operations-impl/#mov","title":"Mov","text":"Architecture Register to Register Vector to Vector x64 \u2705 \u2705 x86 \u2705 \u2705 ARM64 \u2705 \u2705"},{"location":"dev/arch/operations-impl/#movfromstack","title":"MovFromStack","text":"Architecture to Register to Vector x64 \u2705 \u2705 x86 \u2705 \u2705 ARM64 \u2705 \u2705"},{"location":"dev/arch/operations-impl/#movtostack","title":"MovToStack","text":"Architecture to Register to Vector x64 \u2705 \u2705 x86 \u2705 \u2705 ARM64* \u274c \u274c <p>This is not needed for optimal code generation on ARM64, thus was not implemented.</p>"},{"location":"dev/arch/operations-impl/#push","title":"Push","text":"Architecture Register Vector x64 \u2705 \u2705 x86 \u2705 \u2705 ARM64 \u2705 \u2705"},{"location":"dev/arch/operations-impl/#pushstack","title":"PushStack","text":"Architecture Supported Notes x64 \u2705 x86 \u2705 ARM64 \u2705 Will use vector registers when available."},{"location":"dev/arch/operations-impl/#pushconstant","title":"PushConstant","text":"Architecture Supported Notes x64 \u2705 x86 \u2705 ARM64 \u2705 2-5 instructions, depending on constant length."},{"location":"dev/arch/operations-impl/#stackalloc","title":"StackAlloc","text":"Architecture Supported x64 \u2705 x86 \u2705 ARM64 \u2705"},{"location":"dev/arch/operations-impl/#pop","title":"Pop","text":"Architecture to Register to Vector Notes x64 \u2705 \u2705 x86 \u2705 \u2705 ARM64 \u2705 \u2705"},{"location":"dev/arch/operations-impl/#xchg","title":"XChg","text":"Architecture Registers Vectors Notes x64 \u2705 \u2705 * *Requires scratch register x86 \u2705 \u2705 * *Requires scratch register ARM64 \u2705 * \u2705 * *Requires scratch register"},{"location":"dev/arch/operations-impl/#callabsolute","title":"CallAbsolute","text":"Architecture Supported Notes x64 (register) \u2705 Uses scratch register for efficiency. x86 (register) \u2705 Uses scratch register for efficiency. ARM64 (register) \u2705 Uses scratch register (required)"},{"location":"dev/arch/operations-impl/#callrelative","title":"CallRelative","text":"Architecture Supported Notes x64 \u2705 +-2GiB x86 \u2705 +-2GiB ARM64 \u2705 +-128MiB"},{"location":"dev/arch/operations-impl/#return","title":"Return","text":"Architecture Supported Notes x64 \u2705 x86 \u2705 ARM64 \u2705 2 instructions if offset &gt; 0."},{"location":"dev/arch/operations-impl/#architecture-specific-operations","title":"Architecture Specific Operations","text":""},{"location":"dev/arch/operations-impl/#calliprelative","title":"CallIpRelative","text":"Architecture Supported Notes x64 \u2705 x86 \u2753 Unsupported. ARM64 (+- 1MiB) \u2705 2 instructions. ARM64 (+- 4GiB) \u2705 3 instructions."},{"location":"dev/arch/operations-impl/#jumpiprelative","title":"JumpIpRelative","text":"Architecture Supported Notes x64 \u2705 x86 \u2753 Unsupported. ARM64 (+- 1MiB) \u2705 2 instructions. ARM64 (+- 4GiB) \u2705 3 instructions."},{"location":"dev/arch/operations-impl/#optimized-pushpop-operations","title":"Optimized Push/Pop Operations","text":""},{"location":"dev/arch/operations-impl/#multipush","title":"MultiPush","text":"Architecture Supported Notes x64* \u2705 x86* \u2705 ARM64 \u2705 Might fall back to single pop/push if mixing register sizes. <p>* Implemented but not used, due to more efficient code generation alternative.</p>"},{"location":"dev/arch/operations-impl/#multipop","title":"MultiPop","text":"Architecture Supported Notes x64* \u2705 x86* \u2705 ARM64 \u2705 Might fall back to single pop/push if mixing register sizes. <p>* Implemented but not used, due to more efficient code generation alternative.</p>"},{"location":"dev/arch/operations/","title":"Operations","text":"<p>This page provides a reference for all of the various 'operations' implemented by individual JIT(s).</p> <p>For more information about each of the operations, see the source code \ud83d\ude09 (<code>enum Operation&lt;T&gt;</code>).</p>"},{"location":"dev/arch/operations/#needed-for-basic-hooking-support","title":"Needed for Basic Hooking Support","text":""},{"location":"dev/arch/operations/#jumprelative","title":"JumpRelative","text":"<p>Represents jumping to a relative offset from current instruction pointer.</p> Rustx64 (+- 2GiB)ARM64 (+- 128MiB)ARM64 (+- 4GiB)x86 (+- 2GiB) <pre><code>let jump_rel = JumpRelativeOperation {\ntarget_address: 0x200,\n};\n</code></pre> <pre><code>jmp 0x200 ; Jump to address at current IP + 0x200\n</code></pre> <pre><code>b 0x200 ; Branch to address at current IP + 0x200\n</code></pre> <pre><code>adrp x9, #0          ; Load 4K page, relative to PC. (round address down to 4096)\nadd x9, x9, #100     ; Add any missing offset.\nblr x9               ; Branch to location\n</code></pre> <pre><code>jmp 0x200 ; Jump to address at current IP + 0x200\n</code></pre>"},{"location":"dev/arch/operations/#jumpabsolute","title":"JumpAbsolute","text":"<p>Represents jumping to an absolute address stored in a register.</p> <p>JIT is free to encode this as a relative branch if it's possible.</p> Rustx64ARM64x86 <pre><code>let jump_abs = JumpAbsoluteOperation {\nscratch_register: rax,\ntarget_address: 0x123456,\n};\n</code></pre> <pre><code>mov rax, 0x123456 ; Move target address into rax\njmp rax ; Jump to address in rax\n</code></pre> <pre><code>MOVZ x9, #0x3456        ; Set lower bits.\nMOVK x9, #0x12, LSL #16 ; Move upper bits\nbr x9                   ; Branch to location\n</code></pre> <pre><code>mov eax, 0x123456 ; Move target address into eax\njmp eax ; Jump to address in eax\n</code></pre> <p>We prefer this approach to <code>absolute jump</code> because it is faster performance wise.</p>"},{"location":"dev/arch/operations/#jumpabsoluteindirect","title":"JumpAbsoluteIndirect","text":"<p>Represents jumping to an absolute address stored in a memory address.</p> Rustx64 (&lt; 2GiB)x86 (&lt; 2GiB)ARM64 (3 instructions) Variant 0ARM64 (4-6 instructions) Variant 1 <pre><code>let jump_ind = JumpIndirectOperation {\ntarget_address: 0x123456,\n};\n</code></pre> <pre><code>jmp qword [0x123456] ; Jump to address stored at 0x123456\n</code></pre> <pre><code>jmp dword [0x123456] ; Jump to address stored at 0x123456\n</code></pre> <pre><code>; Possible on Multiple of 0x10000 with offset 0-4096\nMOVZ x9, #0x123, LSL #16 ; Store upper 16 bits.\nLDR  x9, [x9, #0x456]    ; Load lower 12 bit offset\nbr x9                    ; Branch to location\n</code></pre> <pre><code>; On any address up to 4GiB + 4096\nMOVZ x9, #0x3456        ; Set lower bits.\nMOVK x9, #0x12, LSL #16 ; Move upper bits\n; Continue until desired address.\nLDR  x9, [x9, #0x0]     ; Load from address.\nbr x9\n</code></pre> <ul> <li>Values in brackets indicate max address usable.</li> </ul> <p>On MacOS, this is not usable, because memory &lt; 2GiB is restricted from access.</p>"},{"location":"dev/arch/operations/#needed-for-wrapper-generation","title":"Needed for Wrapper Generation","text":"<p>This includes functionality like 'parameter injection'.</p>"},{"location":"dev/arch/operations/#mov","title":"Mov","text":"<p>Represents a move operation between two registers.</p> Rustx64ARM64x86 <pre><code>let move_op = MovOperation {\nsource: r8,\ntarget: r9,  };\n</code></pre> <pre><code>mov r9, r8 ; Move r8 into r9\n</code></pre> <pre><code>mov x9, x8 ; Move x8 into x9\n</code></pre> <pre><code>mov ebx, eax ; Move eax into ebx\n</code></pre>"},{"location":"dev/arch/operations/#movfromstack","title":"MovFromStack","text":"<p>Represents a move operation from the stack into a register.</p> Rustx64ARM64x86 <pre><code>let move_from_stack = MovFromStackOperation {\nstack_offset: 8,\ntarget: rbx,\n};\n</code></pre> <pre><code>mov rbx, [rsp + 8] ; Move value at rsp + 8 into rbx\n</code></pre> <pre><code>ldr x9, [sp, #8] ; Load value at sp + 8 into x9\n</code></pre> <pre><code>mov ebx, [esp + 8] ; Move value at esp + 8 into ebx\n</code></pre>"},{"location":"dev/arch/operations/#movtostack","title":"MovToStack","text":"<p>Represents moving a register value onto the stack at a user specified offset.</p> Rustx64ARM64x86 <pre><code>let mov_to_stack = MovToStackOperation {\nregister: rbx,\nstack_offset: 16,  };\n</code></pre> <pre><code>mov [rsp + 16], rbx ; Move rbx onto the stack 16 bytes above rsp \n</code></pre> <pre><code>str x9, [sp, #16] ; Store x9 onto the stack 16 bytes above sp\n</code></pre> <pre><code>mov [esp + 16], ebx ; Move ebx onto the stack 16 bytes above esp\n</code></pre>"},{"location":"dev/arch/operations/#push","title":"Push","text":"<p>Represents pushing a register onto the stack.</p> Rustx64ARM64x86 <pre><code>let push = PushOperation {\nregister: r9,\n};\n</code></pre> <pre><code>push r9 ; Push rbx onto the stack\n</code></pre> <pre><code>sub sp, sp, #8 ; Decrement stack pointer\nstr x9, [sp] ; Store x9 on the stack\n</code></pre> <pre><code>push ebx ; Push ebx onto the stack\n</code></pre>"},{"location":"dev/arch/operations/#pushstack","title":"PushStack","text":"<p>Represents pushing a value from the stack to the stack.</p> Rustx64ARM64x86 <pre><code>let push_stack = PushStackOperation {\noffset: 8,\nitem_size: 8,\n};\n</code></pre> <pre><code>push qword [rsp + 8] ; Push value at rsp + 8 onto the stack\n</code></pre> <pre><code>ldr x9, [sp, #8] ; Load value at sp + 8 into x9\nsub sp, sp, #8 ; Decrement stack pointer\nstr x9, [sp] ; Push x9 onto the stack\n</code></pre> <pre><code>push [esp + 8] ; Push value at esp + 8 onto the stack\n</code></pre>"},{"location":"dev/arch/operations/#pushconstant","title":"PushConstant","text":"<p>Represents pushing a constant value onto the stack.</p> Rustx64ARM64x86 <pre><code>let push_const = PushConstantOperation {\nvalue: 10,\n};\n</code></pre> <pre><code>push 10 ; Push constant value 10 onto stack\n</code></pre> <pre><code>sub sp, sp, #8 ; Decrement stack pointer\nmov x9, 10 ; Move constant 10 into x9\nstr x9, [sp] ; Store x9 on the stack\n</code></pre> <pre><code>push 10 ; Push constant value 10 onto stack\n</code></pre>"},{"location":"dev/arch/operations/#stackalloc","title":"StackAlloc","text":"<p>Represents adjusting the stack pointer.</p> Rustx64ARM64x86 <pre><code>let stack_alloc = StackAllocOperation {\noperand: 8,\n};\n</code></pre> <pre><code>sub rsp, 8 ; Decrement rsp by 8\n</code></pre> <pre><code>sub sp, sp, #8 ; Decrement sp by 8\n</code></pre> <pre><code>sub esp, 8 ; Decrement esp by 8\n</code></pre>"},{"location":"dev/arch/operations/#pop","title":"Pop","text":"<p>Represents popping a value from the stack into a register.</p> Rustx64ARM64x86 <pre><code>let pop = PopOperation {\nregister: rbx,\n};\n</code></pre> <pre><code>pop rbx ; Pop value from stack into rbx\n</code></pre> <pre><code>ldr x9, [sp] ; Load stack top into x9\nadd sp, sp, #8 ; Increment stack pointer\n</code></pre> <pre><code>pop ebx ; Pop value from stack into ebx\n</code></pre>"},{"location":"dev/arch/operations/#xchg","title":"XChg","text":"<p>Represents exchanging the contents of two registers.</p> <p>On some architectures (e.g. ARM64) this requires a scratch register.</p> Rustx64ARM64x86 <pre><code>let xchg = XChgOperation {\nregister1: r9,\nregister2: r8,\nscratch: None,\n};\n</code></pre> <pre><code>xchg r8, r9 ; Swap r8 and r9\n</code></pre> <pre><code>// ARM doesn't have xchg instruction\nmov x10, x8 ; Move x8 into x10 (scratch register)\nmov x8, x9 ; Move x9 into x8\nmov x9, x10 ; Move original x8 (in x10) into x9\n</code></pre> <pre><code>xchg eax, ebx ; Swap eax and ebx\n</code></pre>"},{"location":"dev/arch/operations/#callabsolute","title":"CallAbsolute","text":"<p>Represents calling an absolute address stored in a register or memory.</p> Rustx64ARM64x86 <pre><code>let call_abs = CallAbsoluteOperation {\nscratch_register: r9,\ntarget_address: 0x123456,\n};\n</code></pre> <pre><code>mov rax, 0x123456 ; Move target address into rax\ncall r9 ; Call address in rax\n</code></pre> <pre><code>adr x9, target_func ; Load address of target function into x9\nblr x9 ; Branch and link to address in x9\n</code></pre> <pre><code>mov eax, 0x123456 ; Move target address into eax\ncall eax ; Call address in eax\n</code></pre>"},{"location":"dev/arch/operations/#callrelative","title":"CallRelative","text":"<p>Represents calling a relative offset from current instruction pointer.</p> Rustx64ARM64x86 <pre><code>let call_rel = CallRelativeOperation {\ntarget_address: 0x200,\n};\n</code></pre> <pre><code>call 0x200 ; Call address at current IP + 0x200\n</code></pre> <pre><code>bl 0x200 ; Branch with link to address at current IP + 0x200\n</code></pre> <pre><code>call 0x200 ; Call address at current IP + 0x200\n</code></pre>"},{"location":"dev/arch/operations/#return","title":"Return","text":"<p>Represents returning from a function call.</p> Rustx64ARM64x86 <pre><code>let ret = ReturnOperation {\noffset: 4,\n};\n</code></pre> <pre><code>ret ; Return\nret 4 ; Return and add 4 to stack pointer\n</code></pre> <pre><code>ret ; Return\nadd sp, sp, #4 ; Add 4 to stack pointer\nret ; Return\n</code></pre> <pre><code>ret ; Return\nret 4 ; Return and add 4 to stack pointer\n</code></pre>"},{"location":"dev/arch/operations/#architecture-specific-operations","title":"Architecture Specific Operations","text":"<p>These operations are only available on certain architectures.</p> <p>These are non essential, but can improve compatibility/performance.</p> <p>Enabled by setting <code>JitCapabilities::CanEncodeIPRelativeCall</code> and <code>JitCapabilities::CanEncodeIPRelativeJump</code> in JIT.</p>"},{"location":"dev/arch/operations/#calliprelative","title":"CallIpRelative","text":"<p>Represents calling an IP-relative offset where target address is stored.</p> Rustx64ARM64 (+- 1MB)ARM64 (+- 4GB) <pre><code>let call_rip_rel = CallIpRelativeOperation {\ntarget_address: 0x1000,\n};\n</code></pre> <pre><code>call qword [rip - 16] ; Address 0x1000 is at RIP-16 and contains raw address to call\n</code></pre> <pre><code>ldr x9, 4 ; Read item in a multiple of 4 bytes relative to PC\nblr x9    ; Branch call to location\n</code></pre> <pre><code>adrp x9, #0x0        ; Load 4K page, relative to PC. (round address down to 4096)\nldr x9, [x9, 1110]   ; Read address from offset in 4K page.\nblr x9               ; Branch to location\n</code></pre>"},{"location":"dev/arch/operations/#jumpiprelative","title":"JumpIpRelative","text":"<p>Represents jumping to an IP-relative offset where target address is stored.</p> Rustx64ARM64 (+- 1MB)ARM64 (+- 4GB) <pre><code>let jump_rip_rel = JumpIpRelativeOperation {\ntarget_address: 0x1000,\n};\n</code></pre> <pre><code>jmp qword [rip - 16] ; Address 0x1000 is at RIP-16 and contains raw address to jump\n</code></pre> <pre><code>ldr x9, 4 ; Read item in a multiple of 4 bytes relative to PC\nbr x9     ; Branch call to location\n</code></pre> <pre><code>adrp x9, #0x0        ; Load 4K page, relative to PC. (round address down to 4096)\nldr x9, [x9, 1110]   ; Read address from offset in 4K page.\nbr x9                ; Branch call to location\n</code></pre>"},{"location":"dev/arch/operations/#optimized-pushpop-operations","title":"Optimized Push/Pop Operations","text":"<p>Enabled by setting <code>JitCapabilities::CanMultiPush</code> in JIT.</p>"},{"location":"dev/arch/operations/#multipush","title":"MultiPush","text":"<p>Represents pushing multiple registers onto the stack.</p> <p>Implementations must support push/pop of mixed registers (e.g. Reg+Vector).</p> Rustx64ARM64x86 <pre><code>let multi_push = MultiPushOperation {\nregisters: [\nPushOperation { register: rbx },\nPushOperation { register: rax },\nPushOperation { register: rcx },\nPushOperation { register: rdx },\n],\n};\n</code></pre> <pre><code>push rbx\npush rax\npush rcx\npush rdx ; Push rbx, rax, rcx, rdx onto the stack\n</code></pre> <pre><code>sub sp, sp, #32 ; Decrement stack pointer by 32 bytes  \nstp x9, x8, [sp] ; Store x9 and x8 on the stack\nstp x11, x10, [sp, #16] ; Store x11 and x10 on the stack  \n</code></pre> <pre><code>push ebx\npush eax\npush ecx\npush edx ; Push ebx, eax, ecx, edx onto the stack\n</code></pre>"},{"location":"dev/arch/operations/#multipop","title":"MultiPop","text":"<p>Represents popping multiple registers from the stack.</p> <p>Implementations must support push/pop of mixed registers (e.g. Reg+Vector).</p> Rustx64ARM64x86 <pre><code>let multi_pop = MultiPopOperation {\nregisters: [\nPopOperation { register: rdx },\nPopOperation { register: rcx },\nPopOperation { register: rax },\nPopOperation { register: rbx },\n],\n};\n</code></pre> <pre><code>pop rdx\npop rcx\npop rax\npop rbx ; Pop rdx, rcx, rax, rbx from the stack\n</code></pre> <pre><code>ldp x11, x10, [sp], #16 ; Load x11 and x10 from stack and update stack pointer\nldp x9, x8, [sp], #16 ; Load x9 and x8 from stack and update stack pointer\n</code></pre> <pre><code>pop edx\npop ecx\npop eax\npop ebx ; Pop edx, ecx, eax, ebx from the stack\n</code></pre>"},{"location":"dev/arch/overview/","title":"Architecture Overview","text":"<p>Lists currently supported architectures and their features.</p>"},{"location":"dev/arch/overview/#feature-support","title":"Feature Support","text":"<p>Lists the currently available library features for different architectures.</p> Feature x86 &amp; x64 ARM64 Basic Function Hooking \u2705 \u2705 Code Relocation \u2705* \u2705 Hook Stacking \u2705 \u2705 Calling Convention Wrapper Generation \u2705 \u2705 Optimal Wrapper Generation \u2705 \u2705 Length Disassembler \u2705 \u2705 <ul> <li>x86 should work in all cases, but x64 isn't tested against all 5000+ instructions.</li> </ul>"},{"location":"dev/arch/overview/#required","title":"Required","text":""},{"location":"dev/arch/overview/#basic-function-hooking","title":"Basic Function Hooking","text":"<p>The ability to hook/detour existing application functions.</p>"},{"location":"dev/arch/overview/#how-to-implement","title":"How to Implement","text":"<p>Implement a code writer by inheriting the <code>Jit&lt;TRegister&gt;</code> trait</p> <p>In the writer, implement at least the following operations:  </p> <ul> <li>JumpRelativeOperation.  </li> <li>JumpAbsoluteOperation [needed if platform doesn't support Targeted Memory Allocation].  </li> </ul> <p>Your Platform must also support Permission Change, if it is applicable to your platform.</p>"},{"location":"dev/arch/overview/#length-disassembler","title":"Length Disassembler","text":"<p>Length disassembly is the ability to determine instruction lengths at a given address.</p> <p>A length disassembler determines the minimum amount of instructions (in bytes) needed to copy when hooking a function.</p> <pre><code>/// Disassembles items at `code_address` until the length of instructions\n/// is equal to or greater than `min_length`. \n/// \n/// # Returns\n/// Returns length of instructions (in bytes) greater than or equal to min_length\nfn disassemble_length(code_address: usize, min_length: usize) -&gt; usize\n</code></pre> <p>This is done by disassembling the original instructions at <code>code_address</code>, incrementing a length for each encountered instruction until <code>length &gt;= min_length</code>, then returning the result.</p>"},{"location":"dev/arch/overview/#example","title":"Example","text":"<p>For hooking functions, it's necessary to inject a <code>jmp</code> instruction into the existing code.</p> <p>For example, given this sequence:</p> <pre><code>; x86 Assembly\nDoMathWithTwoNumbers:\ncmp rcx, 0 ; 48 83 F9 00\njg skipAdd ; 7F 0E\n\nmov rax, [rsp + 8] ; 48 8B 44 24 04\nmov rax, [rsp + 16] ; 48 8B 4C 24 04\nadd rax, rcx ; 48 01 C8\nret ; C3\n</code></pre> <p>A `5 byte`` relative jump would overwrite the first two instructions, creating:</p> <pre><code>; x86 Assembly\nDoMathWithTwoNumbers:\njmp stub ; E9 XX XX XX XX\n&lt;INVALID INSTRUCTION&gt; ; 0E\n\nmov rax, [rsp + 8] ; 48 8B 44 24 04\nmov rax, [rsp + 16] ; 48 8B 4C 24 04\nadd rax, rcx ; 48 01 C8\nret ; C3\n</code></pre> <p>When calling the original function again, and thus creating the Reverse Wrapper,  the original instructions overwritten by the <code>jmp</code> will need to be executed.</p> <p>To do this, we must know that the original 2 instructions at <code>DoMathWithTwoNumbers</code> were 6, NOT  <code>5 byte</code>s in length total. Such that when we copy the original code to Reverse Wrapper we get</p> <pre><code>cmp rcx, 0 ; 48 83 F9 00\njg skipAdd ; 7F 0E\n</code></pre> <p>and not</p> <pre><code>cmp rcx, 0 ; 48 83 F9 00\n&lt;INVALID INSTRUCTION&gt; ; 7F\n</code></pre> <p>With a length disassembler, we are able to safely copy all the bytes needed.</p>"},{"location":"dev/arch/overview/#how-to-implement_1","title":"How to Implement","text":"<p>Implement a length disassembler by inheriting the <code>LengthDisassembler</code> trait.</p> <p>Use the algorithm described in example.</p>"},{"location":"dev/arch/overview/#code-relocation","title":"Code Relocation","text":"<p>Code relocation is the ability to rewrite existing code such that existing instructions using PC/IP relative operands still have valid operands post patching.</p> <p>Suppose the following x86 code, which was optimised away to accept first parameter in <code>ecx</code> register:  </p> <pre><code>int DoMathWithTwoNumbers(int operation@ecx, int a, int b) {\n\nif (operation &lt;= 0) {\nreturn a + b;\n}\n\n// Omitted Code Here\n}\n</code></pre> <p>In this case it's possible that there's a jump in the very beginning of the function:  </p> <pre><code>DoMathWithTwoNumbers:\ncmp ecx, 0\njg skipAdd # It's greater than 0\n\nmov eax, [esp + {wordSize * 1}] ; Left Parameter\nmov ecx, [esp + {wordSize * 2}] ; Right Parameter\nadd eax, ecx\nret\n\n; Some Omitted Code Here\n\nskipAdd:\n; Omitted Code Here\n</code></pre> <p>In a scenario like this, the hooking library would overwrite the <code>cmp</code> and <code>jg</code> instruction when it assembles the hook entry ('enter hook'); and when the original function is called again by your hook the, 'wrapper' would now contain this <code>jg</code> instruction.</p> <p>Because <code>jg</code> is an instruction relative to the current instruction address, the library must be able to patch and 'relocate' the function to a new address.</p> <p>Basic code relocation support is needed to stack hooks.</p>"},{"location":"dev/arch/overview/#how-to-implement_2","title":"How to Implement","text":"<p>Implement a relocator by <code>CodeRewriter</code> trait.</p> <p>There is no 'general strategy' for this, however, here are some pieces of advice:</p> <ul> <li>Consider looking at the docs for existing relocators (for RISC, ARM64) is a good reference.  </li> <li>You will need to rewrite all control flow instructions (<code>branch</code> etc.)  </li> <li>You will need to rewrite all instructions which are relative to current Instruction Pointer/Program Counter.  </li> <li>Use disassembler library (if one exists) for your architecture.  </li> </ul>"},{"location":"dev/arch/overview/#optional-extras","title":"Optional (Extras)","text":""},{"location":"dev/arch/overview/#calling-convention-wrapper-generation","title":"Calling Convention Wrapper Generation","text":"<p>The ability to convert between different calling conventions (e.g. <code>cdecl -&gt; stdcall</code>).</p> <p>To implement this, you implement a code writer by inheriting the <code>Jit&lt;TRegister&gt;</code> trait; and  implement the following operations:  </p> <ul> <li>All Non-Optional Instructions.  </li> </ul>"},{"location":"dev/arch/overview/#optimized-wrapper-generation","title":"Optimized Wrapper Generation","text":"<p>If this is checked, it means the wrappers generate optimal code (to best of knowledge).</p> <p>While the wrapper generator does most optimisations themselves, in some cases, it may be possible to perform additional optimisations in the JIT/Code Writer side.</p> <p>For example, the <code>reloaded-hooks</code> wrapper generator might generate the following sequence of pushes for ARM64:</p> <pre><code>push x0\npush x1\n</code></pre> <p>A clever ARM64 compiler however would be able to translate this to:</p> <pre><code>stp x0, x1, [sp, #-16]!\n</code></pre> <p>For some built in optimisations, like this, you can opt into these specialised instructions with <code>JitCapabilities</code> on your <code>Jit&lt;TRegister&gt;</code>.</p> <p>Some others, may be implemented at Jit level instead.</p>"},{"location":"dev/arch/overview/#misc","title":"Misc","text":""},{"location":"dev/arch/overview/#hook-stacking","title":"Hook Stacking","text":"<p>Hook stacking is the ability to hook a function multiple times.</p> <p>This should work flawlessly out of the box if all of the required elements are implemented.</p>"},{"location":"dev/arch/arm64/aarch64/","title":"ARM64","text":"<p>This is just a quick reference sheet for developers.</p> <p>ARM64 is not currently implemented.</p> <ul> <li>Code Alignment: 4 bytes</li> </ul>"},{"location":"dev/arch/arm64/aarch64/#registers","title":"Registers","text":"Register ARM64 (System V) Volatile/Non-Volatile <code>x0</code>-<code>x7</code> Parameter/Result Registers Volatile <code>x8</code> Indirect result location register Volatile <code>x9</code>-<code>x15</code> Local Variables Volatile <code>x16</code>-<code>x17</code> Intra-procedure-call scratch registers Volatile <code>x18</code> Platform register, conventionally the TLS base Volatile <code>x19</code>-<code>x28</code> Registers saved across function calls Non-Volatile <code>x29</code> Frame pointer Non-Volatile <code>x30</code> Link register Volatile <code>sp</code> Stack pointer Non-Volatile <code>xzr</code> Zero register, always reads as zero N/A <code>x31</code> Stack pointer or zero register, contextually reads as either <code>sp</code> or <code>xzr</code> N/A <p>For floating point / SIMD registers:</p> Register ARM64 (System V) Volatile/Non-Volatile <code>v0</code>-<code>v7</code> Parameter/Result registers Volatile <code>v8</code>-<code>v15</code> Temporary registers Volatile <code>v16</code>-<code>v31</code> Registers saved across function calls Non-Volatile"},{"location":"dev/arch/arm64/aarch64/#calling-convention-inference","title":"Calling Convention Inference","text":"<p>It is recommended library users manually specify conventions in their hook functions.\"</p> <p>When the calling convention of <code>&lt;your function&gt;</code> is not specified, wrapper libraries must insert the appropriate default convention in their wrappers.</p>"},{"location":"dev/arch/arm64/aarch64/#rust","title":"Rust","text":"<ul> <li><code>aarch64-unknown-linux-gnu</code>: SystemV</li> <li><code>aarch64-pc-windows-msvc</code>: Windows ARM64</li> </ul>"},{"location":"dev/arch/arm64/aarch64/#c","title":"C","text":"<ul> <li><code>Linux ARM64</code>: SystemV</li> <li><code>Windows ARM64</code>: Windows ARM64</li> </ul>"},{"location":"dev/arch/arm64/code_relocation/","title":"Code Relocation","text":"<p>This page provides a listing of all instructions rewritten as part of the Code Relocation process.</p>"},{"location":"dev/arch/arm64/code_relocation/#adrp","title":"ADR(P)","text":"<p>Purpose:  </p> <p>The <code>ADR</code> instruction in ARM architectures computes the address of a label and writes it to the destination register. </p> <p>Behaviour:  </p> <p>The ADR(P) instruction is rewritten as one of the following: - ADR(P) - ADR(P) + ADD - MOV (1-4 instructions)  </p> <p>Example:</p> <ol> <li> <p>From ADRP to ADR:     <pre><code>// Before: ADRP x0, 0x101000\n// After: ADR x0, 0xFFFFF\n// Parameters: (old_instruction, old_address, new_address)\nrewrite_adr(0x000800B0_u32.to_be(), 0, 4097);\n</code></pre></p> </li> <li> <p>Within 4GiB Range with Offset:     <pre><code>// Before: ADRP x0, 0x101000\n// After: \n//  - ADRP x0, 0x102000\n//  - ADD x0, x0, 1\nrewrite_adr(0x000800B0_u32.to_be(), 4097, 0);\n</code></pre></p> </li> <li> <p>Within 4GiB Range without Offset:     <pre><code>// Before: ADRP x0, 0x101000\n// After: ADRP x0, 0x102000\nrewrite_adr(0x000800B0_u32.to_be(), 4096, 0);\n</code></pre></p> </li> <li> <p>Out of Range:     <pre><code>// PC = 0x100000000\n\n// Before: ADRP, x0, 0x101000\n// After: MOV IMMEDIATE 0x100101000\nrewrite_adr(0x000800B0_u32.to_be(), 0x100000000, 0);\n</code></pre></p> </li> </ol>"},{"location":"dev/arch/arm64/code_relocation/#branch-conditional","title":"Branch (Conditional)","text":"<p>Purpose: The <code>Bcc</code> instruction in ARM architectures performs a conditional branch based on specific condition flags. </p> <p>Behaviour: The Branch Conditional instruction is rewritten as: - BCC - BCC  + [B] - BCC  + [ADRP + ADD + BR] - BCC  + [MOV to Register + Branch Register]   <p><code>&lt;skip&gt;</code> means, invert the condition, and jump over the code inside [] brackets.</p> <p>Example:</p> <ol> <li> <p>Within 1MiB:     <pre><code>// Before: b.eq #4\n// After: b.eq #-4092\n// Parameters: (old_instruction, old_address, new_address, scratch_register)\nrewrite_bcc(0x20000054_u32.to_be(), 0, 4096, Some(17));\n</code></pre></p> </li> <li> <p>Within 128MiB:     <pre><code>// Before: b.eq #0\n// After: \n//   - b.ne #8 \n//   - b #-0x80000000\nrewrite_bcc(0x00000054_u32.to_be(), 0, 0x8000000 - 4, Some(17));\n</code></pre></p> </li> <li> <p>Within 4GiB Range with Address Adjustment:     <pre><code>// Before: b.eq #512\n// After: \n//   - b.ne #16 \n//   - adrp x17, #0x8000000\n//   - add x17, #512\n//   - br x17\nrewrite_bcc(0x00100054_u32.to_be(), 0x8000000, 0, Some(17));\n</code></pre></p> </li> <li> <p>Within 4GiB Range without Offset:     <pre><code>// Before: b.eq #512\n// After: \n//   - b.ne #12\n//   - adrp x17, #-0x8000000 \n//   - br x17\nrewrite_bcc(0x00100054_u32.to_be(), 0, 0x8000000, Some(17));\n</code></pre></p> </li> <li> <p>Last Resort:     <pre><code>// Before: b.eq #0\n// After: \n//   - b.ne #12\n//   - movz x17, #0 \n//   - br x17\nrewrite_bcc(0x00000054_u32.to_be(), 0, 0x100000000, Some(17));\n</code></pre></p> </li> </ol>"},{"location":"dev/arch/arm64/code_relocation/#branch","title":"Branch","text":"<p>Including Branch+Link (BL).</p> <p>Purpose: The <code>B</code> (or <code>BL</code> for Branch+Link) instruction in ARM architectures performs a direct branch (or branch with link) to a specified address. When using the <code>BL</code> variant, the return address (the address of the instruction following the branch) is stored in the link register <code>LR</code>.</p> <p>Behaviour: The Branch instruction is rewritten as one of the following: - B (or BL) - ADRP + BR - ADRP + ADD + BR - MOV  + BR   <p>Example:</p> <ol> <li> <p>Direct Branch within Range:     <pre><code>// Before: b #4096\n// After: b #8192\n// Parameters: (old_instruction, old_address, new_address, scratch_register, link)\nrewrite_b(0x00040014_u32.to_be(), 8192, 4096, Some(17), false);\n</code></pre></p> </li> <li> <p>Within 4GiB with Address Adjustment:     <pre><code>// Before: b #4096\n// After: \n//   - adrp x17, #0x8000000\n//   - br x17\nrewrite_b(0x00040014_u32.to_be(), 0x8000000, 0, Some(17), false);\n</code></pre></p> </li> <li> <p>Within 4GiB Range with Offset:     <pre><code>// Before: b #4096\n// After: \n//   - adrp x17, #0x8000512\n//   - add x17, x17, #512\n//   - br x17\nrewrite_b(0x00040014_u32.to_be(), 0x8000512, 0, Some(17), false);\n</code></pre></p> </li> <li> <p>Out of Range, Use MOV:     <pre><code>// Before: b #4096\n// After: \n//   - movz x17, #... \n//   - ...\n//   - br x17\nrewrite_b(0x00040014_u32.to_be(), 0x100000000, 0, Some(17), false);\n</code></pre></p> </li> <li> <p>Branch with Link within Range:     <pre><code>// Before: bl #4096\n// After: bl #8192\nrewrite_b(0x00040094_u32.to_be(), 8192, 4096, Some(17), true);\n</code></pre></p> </li> </ol>"},{"location":"dev/arch/arm64/code_relocation/#cbz-compare-and-branch-on-zero","title":"CBZ (Compare and Branch on Zero)","text":"<p>Purpose: The <code>CBZ</code> instruction in ARM architectures performs a conditional branch when the specified register is zero. If the register is not zero and the condition is not met, the next sequential instruction is executed.</p> <p>Behaviour: The <code>CBZ</code> instruction is rewritten as one of the following: - CBZ - CBZ  + [B] - CBZ  + [ADRP + BR] - CBZ  + [ADRP + ADD + BR] - CBZ  + [MOV to Register + Branch Register]   <p>Here, <code>&lt;skip&gt;</code> is used to invert the condition and jump over the set of instructions inside the <code>[]</code> brackets if the condition is not met.</p> <p>Example:</p> <ol> <li> <p>Within 1MiB Range:     <pre><code>// Before: cbz x0, #4096\n// After: cbz x0, #8192\n// Parameters: (old_instruction, old_address, new_address)\nrewrite_cbz(0x008000B4_u32.to_be(), 8192, 4096, Some(17));\n</code></pre></p> </li> <li> <p>Within 128MiB Range:     <pre><code>// Before: cbz x0, #4096\n// After: \n//   - cbnz x0, #8\n//   - b #0x8000000\nrewrite_cbz(0x008000B4_u32.to_be(), 0x8000000, 4096, Some(17));\n</code></pre></p> </li> <li> <p>Within 4GiB + 4096 aligned:     <pre><code>// Before: cbz x0, #4096\n// After: \n//   - cbnz x0, &lt;skip 3 instructions&gt; \n//   - adrp x17, #0x8000000\n//   - br x17\nrewrite_cbz(0x008000B4_u32.to_be(), 0x8000000, 0, Some(17));\n</code></pre></p> </li> <li> <p>Within 4GiB with Offset:     <pre><code>// Before: cbz x0, #4096\n// After: \n//   - cbnz x0, &lt;skip 4 instructions&gt;\n//   - adrp x17, #0x8000000\n//   - add x17, #512\n//   - br x17\nrewrite_cbz(0x008000B4_u32.to_be(), 0x8000512, 0, Some(17));\n</code></pre></p> </li> <li> <p>Out of Range (Move and Branch):     <pre><code>// Before: cbz x0, #4096\n// After: \n//   - cbnz x0, &lt;skip X instructions&gt; \n//   - mov x17, &lt;immediate address&gt;\n//   - br x17\nrewrite_cbz(0x008000B4_u32.to_be(), 0x100000000, 0, Some(17));\n</code></pre></p> </li> </ol>"},{"location":"dev/arch/arm64/code_relocation/#ldr-load-register","title":"LDR (Load Register)","text":"<p>This includes Prefetch <code>PRFM</code> which shares opcode with LDR.</p> <p>Purpose: The <code>LDR</code> instruction in ARM architectures is used to load a value from memory into a register. It can use various addressing modes, but commonly it involves an offset from a base register or the program counter.</p> <p>Behaviour: The <code>LDR</code> instruction is rewritten as one of the following, depending on the relocation range:  </p> <ul> <li>LDR Literal</li> <li>ADRP + LDR (with Unsigned Offset)</li> <li>MOV Address to Register + LDR</li> </ul> <p>The choice of rewriting strategy is based on the distance between the old address and the new one, with a preference for the most direct form that satisfies the required address range.</p> <p>If the instruction is Prefetch <code>PRFM</code>, it is discarded if it can't be re-encoded as <code>PRFM (literal)</code>, as prefetching with multiple instructions is probably less efficient than not prefetching at all.</p> <p>Example:</p> <ol> <li> <p>Within 1MiB Range:     <pre><code>// Before: LDR x0, #0\n// After: LDR x0, #4096\n// Parameters: (opcode, new_imm12, rn)\nrewrite_ldr_literal(0x00000058_u32.to_be(), 4096, 0);\n</code></pre></p> </li> <li> <p>Within 4GiB + 4096 aligned:     <pre><code>// Before: LDR x0, #0\n// After: \n//   - adrp x0, #0x100000\n//   - ldr x0, [x0]\n// Parameters: (opcode, new_address, old_address)\nrewrite_ldr_literal(0x00000058_u32.to_be(), 0x100000, 0);\n</code></pre></p> </li> <li> <p>Within 4GiB:     <pre><code>// Before: LDR x0, #512\n// After: \n//   - adrp x0, #0x100000\n//   - ldr x0, [x0, #512]\n// Parameters: (opcode, new_address, old_address)\nrewrite_ldr_literal(0x00100058_u32.to_be(), 0x100000, 0);\n</code></pre></p> </li> <li> <p>Out of Range (Last Resort):     <pre><code>// Before: LDR x0, #512\n// After: \n//   - movz x0, #0, lsl #16\n//   - movk x0, #0x1, lsl #32\n//   - ldr x0, [x0, #512]\n// Parameters: (opcode, new_address, old_address)\nrewrite_ldr_literal(0x00100058_u32.to_be(), 0x100000000, 0);\n</code></pre></p> </li> </ol>"},{"location":"dev/arch/arm64/code_relocation/#tbz-test-and-branch-on-zero","title":"TBZ (Test and Branch on Zero)","text":"<p>Purpose: The <code>TBZ</code> instruction in ARM architectures tests a specified bit in a register and performs a conditional branch if the bit is zero. If the tested bit is not zero, the next sequential instruction is executed.</p> <p>Behaviour: The <code>TBZ</code> instruction is rewritten based on the distance to the new branch target. It is transformed into one of the following patterns: - TBZ - TBZ  + B - TBZ  + ADRP + BR - TBZ  + ADRP + ADD + BR - TBZ  + MOV to Register + Branch Register   <p>Here, <code>&lt;skip&gt;</code> is used to indicate a conditional skip over a set of instructions if the tested bit is not zero. The specific transformation depends on the offset between the current position and the new branch target.</p> <p>Safety: It is crucial to ensure that the provided <code>instruction</code> parameter is a valid <code>TBZ</code> opcode. Incorrect opcodes or assumptions that a different type of instruction is a <code>TBZ</code> may lead to undefined behaviour.</p> <p>Functionality: The <code>rewrite_tbz</code> function alters the <code>TBZ</code> instruction to accommodate a new target address that is outside of its original range. The target address could be within the same 32KiB range or farther, necessitating different rewriting strategies.</p> <p>Example:</p> <ol> <li> <p>Within 32KiB Range:     <pre><code>// Original: tbz x0, #0, #4096\n// Rewritten: tbz x0, #0, #8192\n// Parameters: (old_instruction, old_address, new_address, scratch_reg)\nrewrite_tbz(0x00800036_u32.to_be(), 8192, 4096, Some(17));\n</code></pre></p> </li> <li> <p>Within 128MiB Range:     <pre><code>// Original: tbz x0, #0, #4096\n// Rewritten:\n//   - tbnz x0, #0, #8\n//   - b #0x8000000\nrewrite_tbz(0x00800036_u32.to_be(), 0x8000000, 4096, Some(17));\n</code></pre></p> </li> <li> <p>Within 4GiB Range Aligned to 4096:     <pre><code>// Original: tbz x0, #0, #4096\n// Rewritten:\n//   - tbnz w0, #0, #0xc\n//   - adrp x17, #0x8001000\n//   - br x17\nrewrite_tbz(0x00800036_u32.to_be(), 0x8000000, 0, Some(17));\n</code></pre></p> </li> <li> <p>Within 4GiB Range with Offset:     <pre><code>// Original: tbz x0, #0, #4096\n// Rewritten:\n//    - tbnz w0, #0, #0x10\n//    - adrp x17, #0x8001000\n//    - add x17, x17, #0x512\n//    - br x17\nrewrite_tbz(0x00800036_u32.to_be(), 0x8000512, 0, Some(17));\n</code></pre></p> </li> <li> <p>Out of 4GiB Range (Move and Branch):     <pre><code>// Original: tbz x0, #0, #4096\n// Rewritten:\n//    - tbnz w0, #0, #0x14\n//    - movz x17, #0x1000\n//    - movk x17, #0, lsl #16\n//    - movk x17, #0x1, lsl #32\n//    - br x17\nrewrite_tbz(0x00800036_u32.to_be(), 0x100000000, 0, Some(17));\n</code></pre></p> </li> </ol>"},{"location":"dev/arch/x86/code_relocation/","title":"Code Relocation","text":"<p>This page provides a listing of all instructions rewritten as part of the Code Relocation process for x86 architecture.</p> <p>This page provides a comprehensive overview of the instruction rewriting techniques used in the code  relocation process, specifically tailored for the x64 architecture.</p>"},{"location":"dev/arch/x86/code_relocation/#any-instruction-within-2gib-range","title":"Any Instruction within 2GiB Range","text":"<p>If the new relative branch target is within the encodable range, it is left as relative.</p>"},{"location":"dev/arch/x86/code_relocation/#example-within-relative-range","title":"Example: Within Relative Range","text":"<p>Original: (<code>EB 02</code>) - <code>jmp +2</code> </p> <p>Relocated: (<code>E9 FF 0F 00 00</code>) - <code>jmp +4098</code> </p> <pre><code>// Parameters for test case:\n// - Original Code (Hex)\n// - Original Address\n// - New Address\n// - New Expected Code (Hex)\n`#[case::simple_branch(\"eb02\", 4096, 0, \"e9ff0f0000\")]\n</code></pre> <p>In x86, any address is reachable from any address</p> <p>This is due to integer over/underflow and immediates being 2GiB in size. Therefore relocation simply involves extending the immediate as needed, i.e. <code>jmp 0x12</code> to <code>jmp 0x123012</code> etc.</p> <p>The rest of the page will therefore leave out relative cases, and only focus on offsets greater than 2GiB.</p>"},{"location":"dev/arch/x86/code_relocation/#x64-rewriter-going-beyond-the-2gib-offset","title":"x64 Rewriter: Going Beyond the 2GiB Offset","text":"<p>The x64 rewriter is only suitable for rewriting function prologues.</p> <p>To be able to perform a lot of actions in a position independent manner, this rewriter uses a dummy 'scratch' register which it will overwrite. </p> <p>Scratch register is determined by the following logic:  </p> <ul> <li>Start with <code>Caller Saved Registers</code> (these restored after function call).  </li> <li>Remove all registers used in code being rewritten.  </li> </ul> <p>Because rewriting a lot of code will lead to register exhaustion, it must be reiterated the rewriter can only be used for small bits of code.</p> <p>x64 has over 5000 \u203c\ufe0f instructions that require rewriting. Only a couple hundred are tested currently</p>"},{"location":"dev/arch/x86/code_relocation/#relative-branches","title":"Relative Branches","text":"<p>Instructions such as <code>JMP</code>, <code>CALL</code>, etc.</p> <p>Behaviour:</p> <p>If out of range, it is rewritten using a combination of <code>MOV</code> (move the absolute address into a register) followed by <code>JMP</code> or <code>CALL</code> to that register.</p>"},{"location":"dev/arch/x86/code_relocation/#example","title":"Example","text":"<p>Original: (<code>EB 02</code>) - <code>jmp +2</code> </p> <p>Relocated: (<code>48 B8 04 00 00 80 00 00 00 00 FF E0</code>) - <code>mov rax, 0x80000004</code> - <code>jmp rax</code> </p> <pre><code>// Parameters for test case:\n// - Original Code (Hex)\n// - Original Address\n// - New Address\n// - New Expected Code (Hex)\n#[case::to_abs_jmp_i8(\"eb02\", 0x80000000, 0, \"48b80400008000000000ffe0\")]\n</code></pre>"},{"location":"dev/arch/x86/code_relocation/#jump-conditional","title":"Jump Conditional","text":"<p>Instructions such as <code>jne</code>, <code>jg</code> etc.</p> <p>Behaviour:  </p> <ul> <li>Inverts the branch condition, then jumps over an absolute jump that is encoded using a <code>MOV</code> to set the address and a <code>JMP</code> to that address.</li> </ul>"},{"location":"dev/arch/x86/code_relocation/#example_1","title":"Example","text":"<p>Example:</p> <p>Original: (<code>70 02</code>) - <code>jo +2</code> </p> <p>Relocated: (<code>71 0C 48 B8 04 00 00 80 00 00 00 FF E0</code>): - <code>jno +12 &lt;skip&gt;</code> - <code>mov rax, 0x80000004</code> - <code>jmp rax</code> </p> <pre><code>// Parameters for test case:\n// - Original Code (Hex)\n// - Original Address\n// - New Address\n// - New Expected Code (Hex)\n#[case::jo(\"7002\", 0x80000000, 0, \"710c48b80400008000000000ffe0\")]\n</code></pre>"},{"location":"dev/arch/x86/code_relocation/#loop-instructions","title":"Loop Instructions","text":"<p>Instructions such as <code>LOOP</code>, <code>LOOPE</code>, and <code>LOOPNE</code>.</p> <p>Behaviour:  </p> <p>Handled by either:  </p> <ul> <li>Manually decrementing <code>ECX</code> and using a conditional jump based on the zero flag. (i.e. extend 'loop' address to 32-bit)  </li> </ul> <p>or </p> <ul> <li>Branching the <code>loop</code> function in the opposite direction.  </li> </ul> <p>The strategy used depends on the original instruction.</p>"},{"location":"dev/arch/x86/code_relocation/#example-branch-in-opposite-direction","title":"Example: Branch in Opposite Direction","text":"<p>Original: (<code>E2 FA</code>) - <code>loop -3</code> </p> <p>Relocated: (<code>50 E2 02 EB 0C 48 B8 FD 0F 00 80 00 00 00 00 FF E0</code>) - <code>push rax</code> - <code>loop +2</code> - <code>jmp 0x11</code> - <code>movabs rax, 0x80000ffd</code> - <code>jmp rax</code> </p> <pre><code>// Parameters for test case:\n// - Original Code (Hex)\n// - Original Address\n// - New Address\n// - New Expected Code (Hex)\n#[case::loop_backward_abs(\"50e2fa\", 0x80001000, 0, \"50e202eb0c48b8fd0f008000000000ffe0\")]\n</code></pre>"},{"location":"dev/arch/x86/code_relocation/#jcx-instructions","title":"JCX Instructions","text":"<p>Instructions such as <code>JCXZ</code>, <code>JECXZ</code>, <code>JRCXZ</code>.</p> <p>Behaviour:  </p> <ul> <li>If the target is within 32-bit range, it uses an optimized <code>IMM32</code> encoding.  </li> <li>If out of 32-bit range, it uses a <code>TEST</code> instruction followed by a conditional jump.  </li> </ul>"},{"location":"dev/arch/x86/code_relocation/#example_2","title":"Example","text":"<p>Original: (<code>E3 FA</code>) - <code>jrcxz -3</code> </p> <p>Relocated: (<code>E3 02 EB 0C  48 B8 FD 0F 00 80 00 00 00 00 FF E0</code>) - <code>jrcxz +5</code> - <code>jmp 0x11</code> - <code>mov rax, 0x80000ffd</code> - <code>jmp rax</code> </p> <pre><code>// Parameters for test case:\n// - Original Code (Hex)\n// - Original Address\n// - New Address\n// - New Expected Code (Hex)\n#[case::jrcxz_abs(\"e3fa\", 0x80001000, 0, \"e302eb0c48b8fd0f008000000000ffe0\")]\n</code></pre>"},{"location":"dev/arch/x86/code_relocation/#rip-relative-operand","title":"RIP Relative Operand","text":"<p>At time of writing, this covers around 2800 \u203c\ufe0f instructions</p> <p>Only around a 100 are covered by unit tests though.</p> <p>Covers all instructions which have an IP relative operand, i.e. read/write to a memory address which is relative to the address of the next instruction.</p> <p>Behaviour:  </p> <p>Replace RIP relative operand with a scratch register with the originally intended memory address.</p>"},{"location":"dev/arch/x86/code_relocation/#example_3","title":"Example","text":"<p>Original: (<code>48 8B 1D 08 00 00 00</code>) - <code>mov rbx, [rip + 8]</code> </p> <p>Relocated: (<code>48 B8 0F 00 00 00 01 00 00 00 48 8B 18</code>) - <code>mov rax, 0x10000000f</code> - <code>mov rbx, [rax]</code> </p> <pre><code>// Parameters for test case:\n// - Original Code (Hex)\n// - Original Address\n// - New Address\n// - New Expected Code (Hex)\n#[case::mov_rhs(\"488b1d08000000\", 0x100000000, 0, \"48b80f00000001000000488b18\")]\n</code></pre>"},{"location":"dev/arch/x86/code_relocation/#how-this-is-done","title":"How this is Done","text":"<p><code>reloaded-hooks-rs</code> uses the iced library under the hood for assembly and disassembly. </p> <p>In iced, operands can be broken down to 3 main types:  </p> Name Note register Including Vector Registers memory i.e. <code>[rax]</code> or <code>[rip + 4]</code> imm Immediate, 8/16/32/64 <p>Immediates use multiple types, e.g. <code>Immediate8</code>, <code>Immediate16</code> etc. but on assembler side you can pass them all as Immediate32, so you can group them.</p> <p>Each instruction can have 0-5 operands, where there is at max 1 operand which can be RIP relative.</p> <p>To handle this, a script <code>projects/code-generators/x86/generate_enum_ins_combos.py</code> was used to dump all possible operand permutations from <code>Iced</code> source. Then I wrote functions to handle each possible permutation.</p> <p>1 Operand:  </p> <ul> <li>rip  </li> </ul> <p>2 Operands:</p> <ul> <li>rip, imm</li> <li>rip, reg</li> <li>reg, rip</li> </ul> <p>3 Operands:</p> <ul> <li>reg, reg, rip</li> <li>reg, rip, imm</li> <li>rip, reg, imm</li> <li>rip, reg, reg</li> <li>reg, rip, reg</li> </ul> <p>4 Operands:</p> <ul> <li>reg, reg, rip, imm</li> <li>reg, reg, reg, rip</li> </ul> <p>5 Operands:</p> <ul> <li>reg, reg, reg, rip, imm</li> <li>reg, reg, rip, reg, imm</li> </ul> <p>If <code>reloaded-hooks-rs</code> encounters an instruction with RIP relative operand that uses any of the  following operand permutations, it should successfully patch it.</p>"},{"location":"dev/arch/x86/x86/","title":"x86","text":"<p>This is just a quick reference sheet for developers.</p> <ul> <li>Code Alignment: 16 bytes</li> </ul>"},{"location":"dev/arch/x86/x86/#registers","title":"Registers","text":"Register stdcall (Microsoft x86) cdecl <code>eax</code> Caller-saved, return value Caller-saved, return value <code>ebx</code> Callee-saved Callee-saved <code>ecx</code> Caller-saved Caller-saved <code>edx</code> Caller-saved Caller-saved <code>esi</code> Callee-saved Callee-saved <code>edi</code> Callee-saved Callee-saved <code>ebp</code> Callee-saved Callee-saved <code>esp</code> Callee-saved Callee-saved <p>For floating point registers:</p> Register stdcall (Microsoft x86) cdecl <code>st(0)</code>-<code>st(7)</code> Caller-saved, <code>st(0)</code> used for returning floating point values. Caller-saved, <code>st(0)</code> used for returning floating point values. <code>mm0</code>-<code>mm7</code> Caller-saved Caller-saved <code>xmm0</code>-<code>xmm7</code> Caller-saved Caller-saved <p>Both calling conventions pass function parameters on the stack, in right-to-left order, and they  both return values in <code>eax</code>. For floating-point values or larger structures, the FPU stack or  additional conventions are used. The main difference for function calls is that stdcall expects  the function (callee) to clean up the stack, while cdecl expects the caller to do it.</p>"},{"location":"dev/arch/x86/x86/#calling-convention-inference","title":"Calling Convention Inference","text":"<p>It is recommended library users manually specify conventions in their hook functions.\"</p> <p>When the calling convention of <code>&lt;your function&gt;</code> is not specified, wrapper libraries must insert the appropriate default convention in their wrappers.</p>"},{"location":"dev/arch/x86/x86/#rust","title":"Rust","text":"<ul> <li><code>i686-pc-windows-gnu</code>: cdecl</li> <li><code>i686-pc-windows-msvc</code>: cdecl</li> <li><code>i686-unknown-linux-gnu</code>: SystemV</li> </ul>"},{"location":"dev/arch/x86/x86/#c","title":"C","text":"<ul> <li><code>Linux x86</code>: SystemV</li> <li><code>Windows x86</code>: cdecl</li> </ul>"},{"location":"dev/arch/x86/x86_64/","title":"x86_64","text":"<p>This is just a quick reference sheet for developers.</p> <ul> <li>Code Alignment: 16 bytes</li> </ul>"},{"location":"dev/arch/x86/x86_64/#registers","title":"Registers","text":"<p>The order of the registers is typically as follows for Microsoft x64 ABI: <code>rcx</code>, <code>rdx</code>, <code>r8</code>, <code>r9</code>,  then the rest of the parameters are pushed onto the stack in reverse order (right-to-left).</p> <p>For the System V ABI on x64: <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code>, then the rest of the parameters  are pushed onto the stack in reverse order (right-to-left).</p> Register Microsoft x64 ABI SystemV ABI <code>rax</code> Caller-saved Caller-saved <code>rbx</code> Callee-saved Callee-saved <code>rcx</code> Caller-saved, 1st parameter Caller-saved, 4th parameter <code>rdx</code> Caller-saved, 2nd parameter Caller-saved, 3rd parameter <code>rsi</code> Caller-saved Caller-saved, 2nd parameter <code>rdi</code> Caller-saved Caller-saved, 1st parameter <code>rbp</code> Callee-saved Callee-saved <code>rsp</code> Callee-saved Callee-saved <code>r8</code> Caller-saved, 3rd parameter Caller-saved, 5th parameter <code>r9</code> Caller-saved, 4th parameter Caller-saved, 6th parameter <code>r10</code> Caller-saved Caller-saved <code>r11</code> Caller-saved Caller-saved <code>r12</code> Callee-saved Callee-saved <code>r13</code> Callee-saved Callee-saved <code>r14</code> Callee-saved Callee-saved <code>r15</code> Callee-saved Callee-saved <p>Floating Point Registers (Microsoft)</p> Register Microsoft x64 ABI <code>st(0)</code>-<code>st(7)</code> Caller-saved <code>mm0</code>-<code>mm7</code> Caller-saved <code>xmm0</code>-<code>xmm5</code> Caller-saved, used for floating point parameters. <code>ymm0</code>-<code>zmm5</code> Caller-saved, used for floating point parameters. <code>zmm0</code>-<code>zmm5</code> Caller-saved, used for floating point parameters. <code>xmm6</code>-<code>xmm15</code> Callee-saved. <code>ymm6</code>-<code>ymm15</code> Callee-saved. Upper half must be preserved by the caller <code>zmm6</code>-<code>zmm31</code> Callee-saved. Upper half must be preserved by the caller <p>Floating Point Registers (SystemV)</p> Register SystemV ABI <code>st(0)</code>-<code>st(7)</code> Caller-saved <code>mm0</code>-<code>mm7</code> Caller-saved <code>xmm0</code>-<code>xmm7</code> Caller-saved, used for floating point parameters <code>ymm0</code>-<code>zmm7</code> Caller-saved, used for floating point parameters <code>zmm0</code>-<code>zmm7</code> Caller-saved, used for floating point parameters <code>xmm8</code>-<code>xmm15</code> Caller-saved <code>ymm8</code>-<code>ymm15</code> Caller-saved, used for floating point parameters <code>zmm8</code>-<code>zmm31</code> Caller-saved, used for floating point parameters <p>On Linux, syscalls use R10 instead of RCX in SystemV ABI</p>"},{"location":"dev/arch/x86/x86_64/#intel-apx","title":"Intel APX","text":"<p>Information sourced from Source.</p> <p>Future Intel processors are expected to ship with APX, extending the registers to 32 by adding R16-R31.  </p> <p>These future registers are expected to be caller saved.  </p> <p>To quote document:  </p> <p>Defining all new state (Intel\u00ae APX\u2019s EGPRs) as volatile (caller-saved or scratch)</p>"},{"location":"dev/arch/x86/x86_64/#calling-convention-inference","title":"Calling Convention Inference","text":"<p>It is recommended library users manually specify conventions in their hook functions.\"</p> <p>When the calling convention of <code>&lt;your function&gt;</code> is not specified, wrapper libraries must insert the appropriate default convention in their wrappers.</p>"},{"location":"dev/arch/x86/x86_64/#rust","title":"Rust","text":"<ul> <li><code>x86_64-pc-windows-gnu</code>: Microsoft</li> <li><code>x86_64-pc-windows-msvc</code>: Microsoft</li> <li><code>x86_64-unknown-linux-gnu</code>: SystemV</li> <li><code>x86_64-apple-darwin</code>: SystemV</li> </ul>"},{"location":"dev/arch/x86/x86_64/#c","title":"C","text":"<ul> <li><code>Windows x64</code>: Microsoft</li> <li><code>Linux x64</code>: SystemV</li> <li><code>macOS x64</code>: SystemV</li> </ul>"},{"location":"dev/design/common/","title":"Common Design Notes","text":"<p>Design notes common to all hooking strategies.</p>"},{"location":"dev/design/common/#wrappers","title":"Wrappers","text":""},{"location":"dev/design/common/#wrapper","title":"Wrapper","text":"<p>Wrappers are stubs which convert from the calling convention of the original function to your calling convention.</p> <p>If the calling convention of the hooked function and your function matches, this wrapper is simply just 1 <code>jmp</code> instruction.</p> <p>Wrappers are documented in their own page here.</p>"},{"location":"dev/design/common/#reversewrapper","title":"ReverseWrapper","text":"<p>Stub which converts from your code's calling convention to original function's calling convention</p> <p>This is basically Wrapper with <code>source</code> and <code>destination</code> swapped around</p>"},{"location":"dev/design/common/#hook-memory-layouts-thread-safety","title":"Hook Memory Layouts &amp; Thread Safety","text":"<p>Hooks in <code>reloaded-hooks-rs</code> are structured in a very specific way to ensure thread safety.</p> <p>They sacrifice a bit of memory usage in favour of performance + thread safety.</p> <p>Most hooks, regardless of type have a memory layout that looks something like this:</p> <pre><code>// Size: 2 registers\npub struct Hook\n{\n/// The address of the stub containing bridging code\n/// between your code and custom code. This is the address\n/// of the code that will actually be executed at runtime.\nstub_address: usize,\n\n/// Address of the 'properties' structure, containing\n/// the necessary info to manipulate the data at stub_address\nprops: NonNull&lt;StubPackedProps&gt;,\n}\n</code></pre> <p>Notably, there are two heap allocations. One at <code>stub_address</code>, which contains the executable code, and one at <code>props</code>, which contains packed info of the stub at <code>stub_address</code>.</p> <p>The hooks use a 'swapping' system. Both <code>stub_address</code> and <code>props</code> contains <code>swap space</code>. When you enable or disable a hook, the data in the two 'swap spaces' are swapped around. </p> <p>In other words, when <code>stub_address</code>' 'swap space' contains the code for <code>HookFunction</code> (hook enabled),  the 'swap space' at <code>props</code>' contains the code for <code>Original Code</code>.</p> <p>Thread safety is ensured by making writes within the stub itself atomic, as well as making the emplacing of the jump to the stub in the original application code atomic.</p>"},{"location":"dev/design/common/#stub-layout","title":"Stub Layout","text":"<p>The memory region containing the actual executed code.</p> <p>The stub has two possible layouts, if the <code>Swap Space</code> is small enough such that it can be atomically overwritten, it will look like this:</p> <pre><code>- 'Swap Space' [HookCode / OriginalCode]\n&lt;pad to atomic register size&gt;\n</code></pre> <p>Otherwise, if <code>Swap Space</code> cannot be atomically overwritten, it will look like:</p> <pre><code>- 'Swap Space' [HookCode / OriginalCode]\n- HookCode\n- OriginalCode\n</code></pre> <p>Some hooks may store, extra data after <code>OriginalCode</code>.</p> <p>For example, if calling convention conversion is needed, the <code>HookCode</code> becomes a  ReverseWrapper, and the stub will also contain a Wrapper.</p> <p>If calling convention conversion is needed, the layout looks like this:</p> <pre><code>- 'Swap Space' [ReverseWrapper / OriginalCode]\n- ReverseWrapper\n- OriginalCode\n- Wrapper\n</code></pre>"},{"location":"dev/design/common/#example","title":"Example","text":"<p>Using ARM64 Assembly Hook as an example.</p> <p>If the 'OriginalCode' was:</p> <pre><code>mov x0, x1\nadd x0, x2\n</code></pre> <p>And the 'HookCode' was:</p> <pre><code>add x1, x1\nmov x0, x2\n</code></pre> <p>The memory would look like this when hook is enabled.</p> <pre><code>swap: ; Currently Applied (Hook)\nmov x0, x1\nadd x0, x2\nb back_to_code\n\nhook: ; HookCode\nadd x1, x1\nmov x0, x2\nb back_to_code\n\noriginal: ; OriginalCode\nmov x0, x1\nadd x0, x2\nb back_to_code\n</code></pre> <p>(When <code>sizeof(swap)</code> is larger than biggest possible atomic write.)</p>"},{"location":"dev/design/common/#heap-props-layout","title":"Heap (Props) Layout","text":"<p>Each Assembly Hook contains a pointer to the heap stub (seen above) and a pointer to the heap.</p> <p>The heap contains all information required to perform operations on the stub.</p> <pre><code>- StubPackedProps\n    - Enabled Flag\n    - IsSwapOnly\n    - SwapSize\n    - HookSize\n- [Hook Function / Original Code]\n</code></pre> <p>The data in the heap contains a short `StubPackedProps`` struct, detailing the data stored over in the stub. </p> <p>The <code>SwapSize</code> contains the length of the 'swap' info (and also consequently, offset of <code>HookCode</code>). The <code>HookSize</code> contains the length of the 'hook' instructions (and consequently, offset of <code>OriginalCode</code>).  </p> <p>If the <code>IsSwapOnly</code> flag is set, then this data is to be atomically overwritten.</p>"},{"location":"dev/design/common/#the-enable-disable-process","title":"The 'Enable' / 'Disable' Process","text":"<p>When transitioning between Enabled/Disabled state, we place a temporary branch at <code>entry</code>, this allows us to manipulate the remaining code safely.</p> <p>Using ARM64 Assembly Hook as an example.</p> <p>We start the 'disable' process with a temporary branch:</p> <pre><code>entry: ; Currently Applied (Hook)\nb original ; Temp branch to original\nmov x0, x2\nb back_to_code\n\nhook: ; Backup (Hook)\nadd x1, x1\nmov x0, x2\nb back_to_code\n\noriginal: ; Backup (Original)\nmov x0, x1\nadd x0, x2\nb back_to_code\n</code></pre> <p>Don't forget to clear instruction cache on non-x86 architectures which need it.</p> <p>This ensures we can safely overwrite the remaining code...</p> <p>Then we overwrite <code>entry</code> code with <code>hook</code> code, except the branch:</p> <pre><code>entry: ; Currently Applied (Hook)\nb original     ; Branch to original\nadd x0, x2     ; overwritten with 'original' code.\nb back_to_code ; overwritten with 'original' code.\n\nhook: ; Backup (Hook)\nadd x1, x1\nmov x0, x2\nb back_to_code\n\noriginal: ; Backup (Original)\nmov x0, x1\nadd x0, x2\nb back_to_code\n</code></pre> <p>And lastly, overwrite the branch. </p> <p>To do this, read the original <code>sizeof(nint)</code> bytes at <code>entry</code>, replace branch bytes with original bytes  and do an atomic write. This way, the remaining instruction is safely replaced.</p> <pre><code>entry: ; Currently Applied (Hook)\nadd x1, x1     ; 'original' code.\nadd x0, x2     ; 'original' code.\nb back_to_code ; 'original' code.\n\noriginal: ; Backup (Original)\nmov x0, x1\nadd x0, x2\nb back_to_code\n\nhook: ; Backup (Hook)\nadd x1, x1\nmov x0, x2\nb back_to_code\n</code></pre> <p>This way we achieve zero overhead CPU-wise, at expense of some memory.</p>"},{"location":"dev/design/common/#limits","title":"Limits","text":"<p>Stub info is packed by default to save on memory space. By default, the following limits apply:</p> Property 4 Byte Instruction (e.g. ARM64) Other (e.g. x86) Max Orig Code Length 128KiB 32KiB Max Hook Code Length 128KiB 32KiB <p>These limits may increase in the future if additional required functionality warrants extending metadata length.</p>"},{"location":"dev/design/common/#thread-safety-on-x86","title":"Thread Safety on x86","text":"<p>Thread safety is 'theoretically' not guaranteed for every possible x86 processor, however is satisfied for all modern CPUs.</p> <p>The information below is x86 specific but applies to all architectures with a non-fixed instruction size. Architectures with fixed instruction sizes (e.g. ARM) are thread safe in this library by default.</p>"},{"location":"dev/design/common/#the-theory","title":"The Theory","text":"<p>If the <code>jmp</code> instruction emplaced when switching state overwrites what originally   were multiple instructions, it is theoretically possible that the placing the <code>jmp</code> will make the   instruction about to be executed invalid.</p> <p>For example if the previous instruction sequence was:</p> <pre><code>0x0: push ebp\n0x1: mov ebp, esp ; 2 bytes\n</code></pre> <p>And inserting a jmp produces:</p> <pre><code>0x0: jmp disabled ; 2 bytes\n</code></pre> <p>It's possible that the CPU's Instruction Pointer was at <code>0x1`` at the time of the overwrite, making the</code>mov ebp, esp` instruction invalid.</p>"},{"location":"dev/design/common/#what-happens-in-practice","title":"What Happens in Practice","text":"<p>In practice, modern x86 CPUs (1990 onwards) from Intel, AMD and VIA prefetch instruction in batches  of 16 bytes. We place our stubs generated by the various hooks on 16-byte boundaries for this  (and optimisation) reasons.</p> <p>So, by the time we change the code, the CPU has already prefetched the instructions we are atomically  overwriting.</p> <p>In other words, it is simply not possible to perfectly time a write such that a thread at <code>0x1</code>  (<code>mov ebp, esp</code>) would read an invalid instruction, as that instruction was prefetched and is being  executed from local thread cache.</p>"},{"location":"dev/design/common/#what-is-safe","title":"What is Safe","text":"<p>Here is a thread safety table for x86, taking the above into account:</p> Safe? Hook Notes \u2705 Function Functions start on multiples of 16 on pretty much all compilers, per Intel Optimisation Guide. \u2705 Branch Stubs are 16 aligned. \u2705 Assembly Stubs are 16 aligned. \u2705 VTable VTable entries are <code>usize</code> aligned, and don't cross cache boundaries."},{"location":"dev/design/common/#hook-length-mismatch-problem","title":"Hook Length Mismatch Problem","text":"<p>When a hook is already present, and you wish to stack that hook over the existing hook, certain problems might arise.</p>"},{"location":"dev/design/common/#when-your-hook-is-shorter-than-original","title":"When your hook is shorter than original.","text":"<p>This is notably an issue when a hook entry composes of more than 1 instruction; i.e. on RISC architectures.</p> <p>There is a potential register allocation caveat in this scenario.</p> <p>Pretend you have the following ARM64 function:</p> ARM64C <pre><code>ADD x1, #5\nADD x2, #10\nADD x0, x1, x2\nADD x0, x0, x0\nRET\n</code></pre> <pre><code>x1 = x1 + 5;\nx2 = x2 + 10;\nint x0 = x1 + x2;\nx0 = x0 + x0;\nreturn x0;\n</code></pre> <p>And then, a large hook using an absolute jump with register is applied:</p> <pre><code># Original instructions here replaced\nMOVZ x0, A\nMOVK x0, B, LSL #16\nMOVK x0, C, LSL #32\nMOVK x0, D, LSL #48\nB x0\n# &lt;= branch returns here\n</code></pre> <p>If you then try to apply a smaller hook after applying the large hook, you might run into the following situation:</p> <pre><code># The 3 instructions here are an absolute jump using pointer.\nadrp x9, [0]        ldr x9, [x9, 0x200] br x9\n# Call to original function returns here, back to then branch to previous hook\nMOVK x0, D, LSL #48\nB x0\n</code></pre> <p>This is problematic, with respect to register allocation.  Absolute jumps on some RISC platforms like ARM will always require the use of a scratch register. </p> <p>But there is a risk the scratch register used is the same register (<code>x0</code>) as the register used by the previous hook as the scratch register. In which case, the jump target becomes invalid.</p>"},{"location":"dev/design/common/#resolution-strategy","title":"Resolution Strategy","text":"<ul> <li>Prefer absolute jumps without scratch registers (if possible).  </li> <li>Detect <code>mov</code> + <code>branch</code> combinations for each target architecture.<ul> <li>And extend the function's stolen bytes to cover the entirety.</li> <li>This avoids the scratch register duplication issue, as original hook code will branch to its own code before we end up using the same scratch register.</li> </ul> </li> </ul>"},{"location":"dev/design/common/#when-your-hook-is-longer-than-original","title":"When your hook is longer than original.","text":"<p>Only applies to architectures with variable length instructions. (x86)</p> <p>Some hooking libraries don't clean up remaining stolen bytes after installing a hook.</p> <p>Very notably Steam does this for rendering (overlay) and input (controller support).</p> <p>Consider the original function having the following instructions:</p> <pre><code>48 8B C4      mov rax, rsp\n48 89 58 08   mov [rax + 08], rbx\n</code></pre> <p>After Steam hooks, it will leave the function like this</p> <pre><code>E9 XX XX XX XX    jmp 'somewhere'\n58 08             &lt;invalid instruction. leftover from state before&gt;\n</code></pre> <p>If you're not able to install a relative hook, e.g. need to use an absolute jump</p> <pre><code>FF 25 XX XX XX XX    jmp ['addr']\n</code></pre> <p>The invalid instructions will now become part of the 'stolen' bytes, when you call the original;  and invalid instructions may be executed.</p>"},{"location":"dev/design/common/#resolution-strategy_1","title":"Resolution Strategy","text":"<p>This library must do the following:  </p> <ul> <li>Prefer shorter hooks (<code>relative jump</code> over <code>absolute jump</code>) when possible.  </li> <li>Leave nop(s) after placing any branches, to avoid leaving invalid instructions.<ul> <li>Don't contribute to the problem.   </li> </ul> </li> </ul> <p>There unfortunately isn't much we can do to detect invalid instructions generated by other hooking libraries reliably, best we can do is try to avoid it by using shorter hooks. Thankfully this is not a common issue given most people use the 'popular' libraries.</p>"},{"location":"dev/design/common/#fallback-strategies","title":"Fallback Strategies","text":""},{"location":"dev/design/common/#return-address-patching","title":"Return Address Patching","text":"<p>This feature will not be ported over from legacy <code>Reloaded.Hooks</code>, until an edge case is found that requires this.</p> <p>This section explains how Reloaded handles an edge case within an already super rare case.</p> <p>This topic is a bit more complex, so we will use x86 as example here.</p> <p>For any of this to be necessary, the following conditions must be true:  </p> <ul> <li>An existing relative jump hook exists.  </li> <li>Reloaded can't find free memory within relative jump range.  </li> <li>The existing hook was somehow able to find free memory in this range, but we can't...  (&lt;= main reason this is improbable!!)</li> <li>Free Space from Function Alignment Strategy fails.  </li> <li>The instructions at beginning of the hooked function happened to just perfectly align such that our hook   jump is longer than the existing one.  </li> </ul> <p>The low probability of this happening, at least on Windows and/or Linux is rather insane. It cannot be estimated, but if I were to have a guess, maybe 1 in 1 billion. You'd be more likely to die  from a shark attack.</p> <p>In any case, when this happens, Reloaded performs return address patching.  </p> <p>Suppose a foreign hooking library hooks a function with the following prologue:</p> <pre><code>55        push ebp\n89 e5     mov ebp, esp\n00 00     add [eax], al\n83 ec 20  sub esp, 32 ...\n</code></pre> <p>After hooking, this code would look like:</p> <pre><code>E9 XX XX XX XX  jmp 'somewhere'\n&lt;= existing hook jumps back here when calling original (this) function\n83 ec 20        sub esp, 32 ...\n</code></pre> <p>When the prologue is set up 'just right', such that the existing instrucions divide perfectly into 5 bytes, and we need to insert a 6 byte absolute jmp <code>FF 25</code>, Reloaded must patch the return address.</p> <p>Reloaded has a built in patcher for this super rare scenario, which detects and attempts to patch return addresses of the following patterns:</p> <pre><code>Where nop* represents 0 or more nops.\n\n1. Relative immediate jumps.       \n\n    nop*\n    jmp 0x123456\n    nop*\n\n2. Push + Return\n\n    nop*\n    push 0x612403\n    ret\n    nop*\n\n3. RIP Relative Addressing (X64)\n\n    nop*\n    JMP [RIP+0]\n    nop*\n</code></pre> <p>This patching mechanism is rather complicated, relies on disassembling code at runtime and thus won't be explained here.</p> <p>Different hooking libraries use different logic for storing callbacks. In some cases alignment of code (or rather lack thereof) can also make this operation unreliable, since we rely on disassembling the code at runtime to find jumps back to end of hook. The success rate of this operation is NOT 100%</p>"},{"location":"dev/design/common/#requirements-for-external-libraries-to-interoperate","title":"Requirements for External Libraries to Interoperate","text":"<p>While I haven't studied the source code of other hooking libraries before, I've had no issues in the past with the common Detours and minhook libraries that are commonly used</p>"},{"location":"dev/design/common/#hooking-over-reloaded-hooks","title":"Hooking Over Reloaded Hooks","text":"<p>Libraries which can safely interoperate (stack hooks ontop) of Reloaded Hooks Hooks' must satisfy the following.</p> <ul> <li> <p>Must be able to patch (re-adjust) relative jumps.  </p> <ul> <li>In some cases when assembling call to original function, relative jump target may be out of range,   compatible hooking software must handle this edge case.</li> </ul> </li> <li> <p>Must be able to automatically determine number of bytes to steal from original function.  </p> <ul> <li>This makes it possible to interoperate with the rare times we do a absolute jump when    it may not be possible to do a relative jump (i.e.) as we cannot allocate memory in close   enough proximity. </li> </ul> </li> </ul>"},{"location":"dev/design/common/#reloaded-hooks-hooking-over-existing-hooks","title":"Reloaded Hooks hooking over Existing Hooks","text":"<p>See: Code Relocation</p>"},{"location":"dev/design/wrappers/","title":"Calling Conversion Wrappers","text":"<p>Describes how stubs for converting between different Calling Conventions (ABIs) are generated.</p> <p>This page uses x86 as an example, however the same concepts apply to other architectures.</p> <p>These stubs are what allows <code>Reloaded.Hooks-rs</code> to hook functions which take parameters in custom registers,  allowing developers to skip writing error prone <code>'naked'</code> functions by hand.</p>"},{"location":"dev/design/wrappers/#general-strategy","title":"General Strategy","text":"<p>Setting frame pointer (<code>ebp</code>) is not necessary, as our wrapper shouldn't use it</p> <ul> <li>Backup Non-Volatile Registers (incl. Link Register on Relevant Platforms)</li> </ul> <pre><code># push LR if present on platform\npush ebp\npush ebx\npush edi\npush esi\n</code></pre> <ul> <li>Align the Stack</li> <li> <p>Setup Function Parameters</p> <ul> <li>Re push stack parameters (right to left) of the function being returned</li> </ul> <pre><code># In a loop\npush dword [ebp + {baseStackOffset}]\n</code></pre> <ul> <li>Push register parameters of the function being returned (right to left, reverse loop)</li> <li>Pop parameters into registers of function being called</li> </ul> </li> <li> <p>Reserve Extra Stack Space</p> </li> </ul> <p>Some calling conventions require extra space reserved up front</p> <pre><code>sub esp, {whatever}\n</code></pre> <ul> <li>Call Target Method</li> <li>Setup Return Register</li> </ul> <p>If target function returns in different register than caller expects, might need to for example <code>mov eax, ecx</code>.</p> <pre><code>mov eax, ecx\n</code></pre> <ul> <li>Restore Non-Volatile Registers</li> </ul> <pre><code># Restore non-volatile registers\npop esi\npop edi\npop ebx\npop ebp\n# pop LR if relevant on given platform\n</code></pre> <p>The general implementation for 64-bit is the same, however the stack must be 16 byte aligned at method entry, and for MSFT convention, 32 bytes reserved on stack before call</p> <p>There are also some very minor nuances, which the actual code has to handle, but this is the general jist of it.</p>"},{"location":"dev/design/wrappers/#optimization","title":"Optimization","text":""},{"location":"dev/design/wrappers/#align-wrappers-to-architecture-recommended-alignment","title":"Align Wrappers to Architecture Recommended Alignment","text":"<p>This optimizes CPU instruction fetch, which (on x86) operates on 16 byte boundaries.</p> <p>So we align our wrappers to these boundaries.</p>"},{"location":"dev/design/wrappers/#eliminate-callee-saved-registers","title":"Eliminate Callee Saved Registers","text":"<p>When there are overlaps in callee saved registers between source and target, we can skip backing up those registers.</p> <p>For example, <code>cdecl</code> and <code>stdcall</code> use the same callee saved registers, <code>ebp</code>, <code>ebx</code>, <code>esi</code>, <code>edi</code>. When converting between these two conventions, it is not necessary to backup/restore any of them in the wrapper, because the target function will already take care of that.</p> <p>Example: <code>cdecl target -&gt; stdcall</code> wrapper.</p> BeforeAfter <pre><code># Stack Backup\npush ebp\nmov ebp, esp\n\n# Callee Save\npush ebx\npush edi\npush esi\n\n# Re push parameters\npush dword [ebp + {x}]\npush dword [ebp + {x}]\n\ncall {function}\nadd esp, 8\n\n# Callee Restore\npop esi\npop edi\npop ebx\n\n# Stack Restore\npop ebp\nret 8\n</code></pre> <pre><code># Stack Backup\npush ebp\nmov ebp, esp\n\n# Re push parameters\npush dword [ebp + {x}]\npush dword [ebp + {x}]\n\ncall {function}\nadd esp, 8\n\n# Stack Restore\npop ebp\nret 8\n</code></pre> <p>Pseudocode example. Not verified for accuracy, but it shows the idea</p> <p>In the <code>cdecl -&gt; stdcall</code> example, <code>ebp</code> is considered a callee saved register too, thus it should be possible to optimise into:</p> <pre><code># Re push parameters\npush dword [esp + {x}]\npush dword [esp + {x}]\n\ncall {function}\nadd esp, 8\n\nret 8\n</code></pre>"},{"location":"dev/design/wrappers/#combine-pushpop-operations-when-possible","title":"Combine Push/Pop Operations when Possible","text":"<p>When pushing multiple registers at once, it is possible to remove redundant stack operations.</p> <p>Imagine a situation where you need to push 3 float registers onto the stack; if we pass the instructions from the wrapper generator verbatim [push a, then push b, then push c], we would land with the following:</p> <pre><code>; Push XMM registers\nsub rsp, 16\nmovdqu [rsp], xmm0\nsub rsp, 16\nmovdqu [rsp], xmm1\nsub rsp, 16\nmovdqu [rsp], xmm2\n\n; Pop XMM registers\nmovdqu xmm2, [rsp]\nadd rsp, 16\nmovdqu xmm1, [rsp]\nadd rsp, 16\nmovdqu xmm0, [rsp]\nadd rsp, 16\n</code></pre> <p>This is unoptimal as it can be simplified to:</p> <pre><code># Push Registers to the Stack\nsub rsp, 48\nmovdqu [rsp], xmm0 movdqu [rsp + 16], xmm1\nmovdqu [rsp + 32], xmm2\n\n# Pop three XMM registers from the Stack\nmovdqu xmm0, [rsp]\nmovdqu xmm1, [rsp + 16]\nmovdqu xmm2, [rsp + 32]\nadd rsp, 48\n</code></pre> <p>When generating wrappers, the generator must recognise this pattern, and merge multiple push/pop operations into a single block, wherever possible.</p> <p>It is optimal to access memory sequentially from lowest to highest address.</p>"},{"location":"dev/design/wrappers/#move-between-registers-instead-of-push-pop","title":"Move Between Registers Instead of Push Pop","text":"<p>In some cases it's possible to mov between registers, rather than doing an explicit push+pop operation</p> <p>Suppose you have a <code>custom target -&gt; stdcall</code> wrapper. Custom is defined as <code>int@eax FastAdd(int a@eax, int b@ecx)</code>.  </p> <p>Normally wrapper generation will convert the arguments like this:  </p> <pre><code># Re-push STDCALL arguments to stack\npush dword [esp + {x}]\npush dword [esp + {x}]\n\n# Pop into correct registers\npop eax\npop ecx\n\n# Call that function\n# ...\n</code></pre> <p>There's opportunities for optimisation here; notably you can do:</p> <pre><code># Pop into correct registers\nmov eax, [esp + {x}]\nmov ecx, [esp + {x}]\n\n# Call that function\n# ...\n</code></pre> <p>Optimising cases where the source/from convention, e.g. <code>custom target -&gt; stdcall</code> has no register  parameters is trivial, since you can directly mov into the intended target register. And this is  the most common use case in x86.</p> <p>For completeness, it should be noted that in the opposite direction <code>stdcall target -&gt; custom</code>, such as one that would be used in entry point of a hook (ReverseWrapper), no optimisation is needed here, as all registers are directly pushed without any extra steps.</p> <p>In the backend, the wrapper generator keeps track of current stack pointer (assuming start is '0'); and uses that information to match the push and pop operations accordingly \ud83d\ude09</p>"},{"location":"dev/design/wrappers/#with-register-to-register","title":"With Register to Register","text":"<p>In x64, and more advanced x86 scenarios where both to/from calling convention have register parameters, mov optimisation is not trivial.</p>"},{"location":"dev/design/wrappers/#basic-case","title":"Basic Case","text":"<p>Suppose you have a a function to add 'health' to a character that's in a struct or class. i.e. <code>int AddHealth(Player* this, int amount)</code>.  (Note: The 'this' parameter to struct instance is implicit and added during compilation.)</p> C++x64 asm (SystemV)x64 asm (Microsoft) <pre><code>class Player {\nint mana;\nint health;\n\nvoid AddHealth(int amount) {\nhealth += amount;\n}\n};\n</code></pre> <pre><code>add dword [rdi+4], esi\nret\n</code></pre> <p>See for yourself.</p> <pre><code>add dword [rcx+4], edx\nret\n</code></pre> <p>See for yourself.</p> <p>If you were to make a <code>SystemV target -&gt; Microsoft</code> wrapper; you would have to move the two registers from <code>rcx, rdx</code> to <code>rdi, rsi</code>.</p> <p>Therefore, a wrapper might have code that looks something like:  </p> <pre><code># Push register parameters of the function being returned (right to left, reverse loop)\npush rdx\npush rcx\n\n# Pop parameters into registers of function being called\npop rdi\npop rsi\n</code></pre> <p>In this case, it is possible to optimise with:</p> <pre><code>mov rdi, rcx # last push, first pop\nmov rsi, rdx # second last push, second pop\n</code></pre> <p>Provided that the wrapper correctly saves and restores callee moved registers for returned method, i.e. backs up <code>RBX, RBP, RDI, RSI, RSP, R12, R13, R14, and R15</code>, this is fine.</p> <p>Or in the case of this wrapper, just <code>RDI, RSI</code> (due to overlap within the 2 conventions).</p> <p>The 'strategy' to generate code for this optimisation is keeping track of stack, start between <code>push</code> and <code>pop</code> in the ASM and pair the registers in the corresponding <code>push</code> and <code>pop</code> operations together, going outwards until there is no push/pop left.</p>"},{"location":"dev/design/wrappers/#advanced-case","title":"Advanced Case","text":"<p>This is just another example.</p> <p>Suppose we add 2 more parameters...</p> C++x64 asm (SystemV)x64 asm (Microsoft) <pre><code>class Player {\nint mana;\nint health;\nint money;\n\nvoid AddStats(int health, int mana, int money) {\nthis-&gt;health += health;\nthis-&gt;mana += mana;\nthis-&gt;money += money;\n}\n};\n</code></pre> <pre><code>add dword [rdi+4], esi # health\nadd dword [rdi], edx   # mana\nadd dword [rdi+8], ecx # money\nret\n</code></pre> <p>See for yourself.</p> <pre><code>add dword [rcx+4], edx # health\nadd dword [rcx], r8d   # mana\nadd dword [rcx+8], r9d # money\nret\n</code></pre> <p>See for yourself.</p> <p>There is now an overlap between the registers used.</p> <p>Microsoft convention uses: - <code>rcx</code> for self - <code>rdx</code> for health  </p> <p>SystemV uses: - <code>rcx</code> for money - <code>rdx</code> for mana  </p> <p>The wrapper now does the following</p> UnoptimisedOptimised (Contains Bug) <pre><code># Push register parameters of the function being returned (right to left, reverse loop)\npush rcx\npush rdx\npush rsi\npush rdi\n\n# Pop parameters into registers of function being called\npop rcx\npop rdx\npop r8\npop r9\n</code></pre> <pre><code>mov rcx, rdi\nmov rdx, rsi\nmov r8, rdx\nmov r9, rcx\n</code></pre> <p>The optimised version of code above contains a bug.</p> <p>There is a bug because both conventions have overlapping registers, notably <code>rcx</code> and <code>rdx</code>. When you try to do <code>mov r8, rdx</code>, this pushes invalid data, as <code>rdx</code> was already overwritten.</p> <p>In this specific case, you can reverse the order of operations, and get a correct result:</p> <pre><code># Reversed\nmov r9, rcx\nmov r8, rdx\nmov rdx, rsi\nmov rcx, rdi\n</code></pre> <p>However might not always be the case.</p> <p>When generating wrappers, we must perform a validation check to determine if any source register in <code>mov target, source</code> hasn't already been overwritten by a prior operation.</p>"},{"location":"dev/design/wrappers/#reordering-operations","title":"Reordering Operations","text":"<p>In the Advanced Case we saw that it's not always possible to perform mov optimisation.</p> <p>This problem can be solved with a <code>Directed Acyclic Graph</code>.</p> <p>This problem can be solved in <code>O(n)</code> complexity with a <code>Directed Acyclic Graph</code>, where each node represents a register and an edge (arrow) from Node A to Node B represents a move from register A to register B.</p> <p>The above (buggy) code would be represented as: <pre><code>flowchart TD\n    RDI --&gt; RCX\n    RSI --&gt; RDX\n    RDX --&gt; R8\n    RCX --&gt; R9</code></pre></p> <p>RDI writes to RCX which writes to R9, which is now invalid. We can determine the correct <code>mov</code> order, by processing them in reverse order of their dependencies</p> <ul> <li><code>mov r9, rcx</code> before <code>mov rcx, rdi</code></li> <li><code>mov r8, rdx</code> before <code>mov rdx, rsi</code></li> </ul> <p>Exact order encoded depends on algorithm implementation in code; as long as the 2 derived rules are followed.</p>"},{"location":"dev/design/wrappers/#handling-cycles-2-node-cycle","title":"Handling Cycles (2 Node Cycle)","text":"<p>Suppose we have 2 calling conventions with reverse parameter order. For this example we will define  convention <code>\ud83d\udc31call</code>. <code>\ud83d\udc31call</code> uses the reverse register order of Microsoft compiler.</p> Cx64 (Microsoft)x64 (<code>\ud83d\udc31call</code>) <pre><code>int AddWithShift(int a, int b) {\nreturn (a * 16) + b;\n}\n</code></pre> <pre><code>shl ecx, 4\nlea eax, dword [rdx+rcx]\nret\n</code></pre> <pre><code>shl edx, 4\nlea eax, dword [rcx+rdx]\nret\n</code></pre> <p>The ASM to do the calling convention transformation becomes:</p> UnoptimisedOptimised (Contains Bug) <pre><code># Push register parameters of the function being returned (right to left, reverse loop)\npush rcx\npush rdx\n\n# Pop parameters into registers of function being called\npop rcx\npop rdx\n</code></pre> <pre><code>mov rcx, rdx\nmov rdx, rcx\n</code></pre> <p>There is now a cycle.</p> <pre><code>flowchart TD\n    RCX --&gt; RDX\n    RDX --&gt; RCX</code></pre> <p>In this trivial example, you can use <code>xchg</code> or 3 <code>mov</code>(s) to swap between the two registers.</p> xchgmov <pre><code>xchg rcx, rdx\n</code></pre> <pre><code>mov {temp}, rdx\nmov rdx, rcx\nxor rcx, {temp}\n</code></pre> <p>On some Intel architectures, the <code>mov</code> approach can reportedly be faster, however, it's not possible to procure a scratch register in all cases.</p> <p>I'll welcome any PRs that detect and write the more optimal choice on a given architecture, however this is not planned for main library.</p> <p>Adding instructions also means the wrapper might overflow to the next multiple of 16 bytes, causing  more instructions to be fetched when it otherwise won't happend with xchg, potentially losing any  benefits gained on those architectures.</p> <p>The mappings done in <code>Reloaded.Hooks</code> are a 1:1 bijective mapping. Therefore any cycle of just 2 registers can be resolved by simply swapping the involved registers.</p>"},{"location":"dev/design/wrappers/#handling-cycles-multi-register-cycle","title":"Handling Cycles (Multi Register Cycle)","text":"<p>Now imagine doing a mapping which involves 3 registers, <code>r8</code> - <code>r10</code>, and all registers need to be <code>mov'd</code>.</p> <pre><code>flowchart TD\n    R8 --&gt; R9\n    R9 --&gt; R10\n    R10 --&gt; R8</code></pre> <pre><code>mov R9, R8\nmov R10, R9\nmov R8, R10\n</code></pre> <p>To resolve this, we backup the register at the end of the cycle (in this case R10), disconnect it from the first register in the cycle and resolve as normal.</p> <p>i.e. we solve for</p> <pre><code>flowchart TD\n    R8 --&gt; R9\n    R9 --&gt; R10</code></pre> <p>Then write original value of R10 into R8 after this code is converted into <code>mov</code> sequences.</p> <p>This can be done using the following strategies:  </p> <ul> <li><code>mov</code> into scratch register.  <ul> <li>For mid-function hooks (<code>AsmHook</code>) prefer callee saved register which is not a parameter.  </li> <li>For function hooks, use a caller saved register.  </li> </ul> </li> <li><code>push</code> + <code>pop</code> register.  </li> </ul> ASM (mov scratch)ASM (push+pop) <pre><code># Move value from end of cycle into caller saved register (scratch)\nmov RAX, R10\n\n# Original (after reorder)\nmov R10, R9\nmov R9, R8\n\n# Move from caller saved register into first in cycle.\nmov R8, RAX\n</code></pre> <pre><code># Push value from end of cycle into stack\npush R10\n\n# Original (after reorder)\nmov R10, R9\nmov R9, R8\n\n# Pop into intended place from stack\npop R8\n</code></pre> <p>When possible to get scratch register, use <code>mov</code>, otherwise use <code>push</code>.</p>"},{"location":"dev/design/wrappers/#idea-eliminate-return-address","title":"Idea: Eliminate Return Address","text":"<p>This is a theoretical idea, not implemented in library.</p> <p>Only applies to platforms like x86 return addresses on stack.</p> <p>In some cases, like converting between <code>stdcall</code> and <code>cdecl</code>; it might be possible to reuse the same parameters from the stack. Take into account the previous example:</p> <pre><code># Re push parameters\npush dword [esp + {x}]\npush dword [esp + {x}]\n\ncall {function}\nadd esp, 8\n\nret 8\n</code></pre> <p>Strictly speaking, to convert from <code>stdcall</code> to <code>cdecl</code>, you will only need to convert from caller stack cleanup to callee stack cleanup i.e. <code>ret 8</code>.</p> <p>In this case, re-pushing parameters is redundant, as the pushed parameters from the previous method call are on stack and can still be re-used.</p> <p>What we can instead do, is overwrite the return address and jump to our code.</p> <pre><code># Pop previous return address from stack\nmov [esp], {addressPostJump} # replace return address\njmp {function} # jump to our function\nadd esp, 8 # our function returns here due to changed return address\nret 8\n</code></pre>"},{"location":"dev/design/wrappers/#technical-limitations","title":"Technical Limitations","text":"<p>Wrapper generation does not have understanding of any specific ABI, and as such cannot always be 100% correct in edge cases.</p>"},{"location":"dev/design/wrappers/#wrappers-dont-understand-abi-specific-rules","title":"Wrappers Don't understand ABI Specific Rules","text":"<p>Some ABIs have unconventional rules for handling edge cases.</p> <p>For example, consider the following rule used by the RISC-V ABI.</p> <p>When primitive arguments twice the size of a pointer-word are passed on the stack, they are naturally aligned. When they are passed in the integer registers, they reside in an aligned even-odd register pair, with the even register holding the least-significant bits. In RV32, for example, the function void foo(int, long long) is passed its first argument in a0 and its second in a2 and a3. Nothing is passed in a1.</p> <p>The wrappers cannot know or understand the intricate rules such as this that are imposed by an ABI.</p>"},{"location":"dev/design/wrappers/#allocating-mixed-size-registers-is-tricky","title":"Allocating Mixed Size Registers is Tricky.","text":"<p>Optimized code does not suffer from this bug.</p>"},{"location":"dev/design/wrappers/#the-problem","title":"The Problem","text":"<p>Consider a function which spills a float register <code>xmm0</code>, and an <code>nint</code> (native size integer). A <code>Push</code> is basically a sequence of <code>sub</code> and then <code>mov</code>.</p> <p>So (pretend ASM below is valid)</p> <pre><code>push xmm0\npush rax\n</code></pre> <p>Would become</p> <pre><code>sub rsp, 16\nmov [rsp], xmm0\nsub rsp, 8\nmov [rsp], rax\n</code></pre> <p>This is invalid, because the contents of rax will now replace half of the <code>xmm0</code> register on the stack. How ABIs and compilers deal with this isn't always well standardised; some only consider lower bits volatile, (Microsoft x64) while others don't preserve the bigger registers at all (SystemV x64).</p> <p>Our strategy will be to try rearrange the stack operations to avoid this problem, starting by pushing smaller registers first, and then larger registers, effectively creating:</p> <pre><code>sub rsp, 8\nmov [rsp], rax\nsub rsp, 16\nmov [rsp], xmm0\n</code></pre>"},{"location":"dev/design/wrappers/#when-using-optimized-code","title":"When using Optimized Code","text":"<p>Currently with optimizations enabled, this code compiles as:</p> <pre><code>sub rsp, 24\nmov [rsp], xmm0\nmov [rsp + 16], rax\n</code></pre> <p>Which is valid.</p>"},{"location":"dev/design/wrappers/#wrappers-currently-dont-understand-how-to-split-larger-registers","title":"Wrappers (Currently) Don't understand how to split larger registers.","text":"<p>Some calling conventions, have rules where larger values (e.g. 128-bit values on x64) are split into 2 registers.</p> <p>The wrapper generator cannot generate code for these functions currently.</p>"},{"location":"dev/design/assembly-hooks/overview/","title":"Assembly Hooks","text":"<p>Replacing arbitrary assembly sequences (a.k.a. 'mid function hooks').</p> <p>This hook is used to make small changes to existing logic, for example injecting custom logic for existing conditional branches (<code>if</code> statements).</p> <p>Limited effectiveness if Code Relocation is not available.</p> <p>I'm not a security person/researcher. I just make full stack game modding tools, mods and libraries. Naming in these design docs might be unconventional.</p> <p>This hook works by injecting a <code>jmp</code> instruction inside the middle of an arbitrary assembly sequence to custom code. The person using this hook must be very careful not to break the program  (corrupt stack, used registers, etc.).</p>"},{"location":"dev/design/assembly-hooks/overview/#high-level-diagram","title":"High Level Diagram","text":""},{"location":"dev/design/assembly-hooks/overview/#key","title":"Key","text":"<ul> <li><code>Original Code</code>: Middle of an arbitrary sequence of assembly instructions where a <code>branch</code> to custom code is placed.  </li> <li><code>Hook Function</code>: Contains user code, including original code (depending on user preference).  <ul> <li>When the hook is deactivated, this contains the original code only.</li> </ul> </li> <li><code>Original Stub</code>: Original code (used when hook disabled).  </li> </ul>"},{"location":"dev/design/assembly-hooks/overview/#when-activated","title":"When Activated","text":"<pre><code>flowchart TD\n    O[Original Code]\n    HK[Hook Function]\n\n    O -- jump --&gt; HK\n    HK -- jump back --&gt; O</code></pre> <p>When the hook is activated, a <code>branch</code> is placed in the middle of the original assembly instruction sequence to your hook code.</p> <p>Your code (and/or original code) is then executed, then it branches back to original code.</p>"},{"location":"dev/design/assembly-hooks/overview/#when-deactivated","title":"When Deactivated","text":"<pre><code>flowchart TD\n    O[Original Function]\n    HK[\"Hook Function &amp;lt;Overwritten with Original Code&amp;gt;\"]\n\n    O -- jump --&gt; HK\n    HK -- jump back --&gt; O</code></pre> <p>When the hook is deactivated, the 'Hook Function' is overwritten in-place with original instructions  and a jump back to your code.</p>"},{"location":"dev/design/assembly-hooks/overview/#usage-notes","title":"Usage Notes","text":"<p>Assembly Hooks should allow both Position Independent Code and Position Relative Code</p> <p>With that in mind, the following APIs should be possible: </p> <pre><code>/// Creates an Assembly Hook given existing position independent assembly code,\n/// and address which to hook.\n/// # Arguments\n/// * `hook_address` - The address of the function or mid-function to hook.\n/// * `asm_code` - The assembly code to execute, precompiled.\nfn from_pos_independent_code_and_function_address(hook_address: usize, asm_code: &amp;[u8]);\n\n/// Creates an Assembly Hook given existing position assembly code,\n/// and address which to hook.\n/// \n/// # Arguments\n/// * `hook_address` - The address of the function or mid-function to hook.\n/// * `asm_code` - The assembly code to execute, precompiled.\n/// * `code_address` - The original address of asm_code. \n/// \n/// # Remarks\n/// Code in `asm_code` will be relocated to new target address. \nfn from_code_and_function_address(hook_address: usize, asm_code: &amp;[u8], code_address: usize);\n\n/// Creates an Assembly Hook given existing position assembly code,\n/// and address which to hook.\n/// \n/// # Arguments\n/// * `hook_address` - The address of the function or mid-function to hook.\n/// * `asm_isns` - The assembly instructions to place at this address.\n/// \n/// # Remarks\n/// Code in `asm_code` will be relocated to new target address. \nfn from_instructions_and_function_address(hook_address: usize, asm_isns: &amp;[Instructions]);\n</code></pre> <p>Using overloads for clarity, in library all options should live in a struct.</p> <p>Code using <code>from_code_and_function_address</code> is to be preferred for usage, as users will be able to use relative branches for improved efficiency. (If they are out of range, hooking library will rewrite them)</p> <p>For pure assembly code, users are expected to compile code externally using something like <code>FASM</code>,  put the code in their program/mod (as byte array) and pass that directly as <code>asm_code</code>.</p> <p>For people who want to call their own program/mod(s) from assembly, there will be a wrapper API around <code>Jit&lt;TRegister&gt;</code> and its various Operations. This API will be cross-architecture and should contain all the necessary operations required for setting up stack/registers and calling user code.</p> <p>Programmers are also expected to provide 'max allowed hook length' with each call.</p>"},{"location":"dev/design/assembly-hooks/overview/#hook-lengths","title":"Hook Lengths","text":"<p>The expected hook lengths for each architecture</p> <p>When using the library, the library will use the most optimal possible <code>jmp</code> instruction to get to the user hook.  </p> <p>When calling one of the functions to create an assembly hook, the end user should specify their max permissible assembly hook length.  </p> <p>If a hook cannot be satisfied within that constraint, then library will throw an error.</p> <p>The following table below shows common hook lengths, for:  </p> <ul> <li><code>Relative Jump</code> (best case)  </li> <li>Targeted Memory Allocation (TMA) (expected best case) when above <code>Relative Jump</code> range.  </li> <li>Worst case scenario.  </li> </ul> Architecture Relative TMA Worst Case x86[1] 5 bytes (+- 2GiB) 5 bytes 5 bytes x86_64 5 bytes (+- 2GiB) 6 bytes[2] 13 bytes[3] x86_64 (macOS) 5 bytes (+- 2GiB) 13 bytes[4] 13 bytes[3] ARM64 4 bytes (+- 128MiB) 12 bytes[6] 20 bytes[5] ARM64 (macOS) 4 bytes (+- 128MiB) 12 bytes[6] 20 bytes[5] <p>[1]: x86 can reach any address from any address with relative branch due to integer overflow/wraparound. [2]: <code>jmp [&lt;Address&gt;]</code>, with &lt;Address&gt; at &lt; 2GiB. [3]: <code>mov &lt;reg&gt;, address</code> + <code>call &lt;reg&gt;</code>. +1 if using an extended reg. [4]: macOS restricts access to <code>&lt; 2GiB</code> memory locations, so absolute jump must be used. +1 if using an extended reg. [5]: MOVZ + MOVK + LDR + BR. [6]: ADRP + ADD + BR.  </p>"},{"location":"dev/design/assembly-hooks/overview/#thread-safety-memory-layout-state-switching","title":"Thread Safety, Memory Layout &amp; State Switching","text":"<p>Common: Thread Safety &amp; Memory Layout</p>"},{"location":"dev/design/assembly-hooks/overview/#legacy-compatibility-considerations","title":"Legacy Compatibility Considerations","text":"<p>As <code>reloaded-hooks-rs</code> intends to replace <code>Reloaded.Hooks</code> is must provide certain functionality for backwards compatibility.</p> <p>Once <code>reloaded-hooks-rs</code> releases, the legacy <code>Reloaded.Hooks</code> will be a wrapper around it.</p> <p>This means a few functionalities must be supported here:</p> <ul> <li> <p>Setting arbitrary 'Hook Length'.</p> <ul> <li>This is the amount of bytes stolen from the original code to be included as 'original code' in hook.</li> <li>On x86 <code>Reloaded.Hooks</code> users create an ASM Hook (with default <code>PreferRelativeJump == false</code> and <code>HookLength == -1</code>) the wrapper for legacy API must set <code>'Hook Length' == 7</code> to emulate absolute jump size.</li> <li>Respecting <code>MaxOpcodeSize</code> from original API should be sufficient.</li> </ul> </li> <li> <p>Supporting Assembly via FASM.</p> <ul> <li>As this is only possible in Windows (FASM can't be recompiled on other OSes as library), this feature will be getting dropped.</li> <li>The <code>Reloaded.Hooks</code> wrapper will continue to ship FASM for backwards compatibility, however mods are expected to migrate to the new library in the future.</li> </ul> </li> </ul>"},{"location":"dev/design/assembly-hooks/overview/#limits","title":"Limits","text":"<p>Assembly hook info is packed by default to save on memory space. By default, the following limits apply:</p> Property 4 Byte Instruction (e.g. ARM64) Other (e.g. x86) Max Orig Code Length 128KiB 32KiB Max Hook Code Length 128KiB 32KiB <p>These limits may increase in the future if additional functionality warrants extending metadata length.</p>"},{"location":"dev/design/branch-hooks/overview/","title":"Branch Hooks","text":"<p>Replaces a <code>branch</code> (call/jump) to an existing method with a new one.</p> <p>This hook is commonly used when you want to change behaviour of a function, but only for certain callers.</p> <p>For example, if you have a method <code>Draw2DElement</code> that's used to draw an object to the screen, but you only want to move a certain element that's rendered by <code>Draw2DElement</code>, you would use a Branch Hook to replace <code>call Draw2DElement</code> to <code>call YourOwn2DElement</code>.</p> <p>Only guaranteed to work on platforms with Targeted Memory Allocation</p> <p>Because the library needs to be able to acquire memory in proximity of the original function.  </p> <p>Usually this is almost always achievable, but cases where Denuvo DRM inflates ARM64 binaries  (20MB -&gt; 500MB) may prove problematic as ARM64 has +-128MiB range for relative jumps.</p> <p>I'm not a security person/researcher. I just make full stack game modding tools, mods and libraries. Naming in these design docs might be unconventional.</p> <p>This hook works by replacing the target of a <code>call</code> (a.k.a. Branch with Link) instruction with a new target.</p>"},{"location":"dev/design/branch-hooks/overview/#comparison-with-function-hook","title":"Comparison with Function Hook","text":"<p>A Branch Hook is really a specialised variant of function hook.</p> <p>Notably it differs in the following ways:</p> <ul> <li> <p>There is no Wrapper To Call Original Function as no instructions are stolen.  </p> <ul> <li>Your method will directly call original instead. </li> </ul> </li> <li> <p>You <code>call</code> the ReverseWrapper instead of <code>jump</code>ing to it.</p> </li> <li>Code replacement is at caller level rather than function level.</li> </ul>"},{"location":"dev/design/branch-hooks/overview/#high-level-diagram","title":"High Level Diagram","text":""},{"location":"dev/design/branch-hooks/overview/#key","title":"Key","text":"<ul> <li><code>Caller Function</code>: Function which originally called <code>Original Method</code>.  </li> <li><code>ReverseWrapper</code>: Translates from original function calling convention to yours. Then calls your function.  </li> <li><code>&lt;Your Function&gt;</code>: Your Rust/C#/C++/Asm code.</li> <li><code>Original Method</code>: Original method to be called.  </li> </ul>"},{"location":"dev/design/branch-hooks/overview/#when-activated","title":"When Activated","text":"<pre><code>flowchart TD\n    CF[Caller Function]\n    RW[Stub]\n    HK[\"&amp;lt;Your Function&amp;gt;\"]\n    OM[Original Method]\n\n    CF -- \"call wrapper\" --&gt; RW\n    RW -- jump to your code --&gt; HK\n    HK -. \"Calls &amp;lt;Optionally&amp;gt;\" .-&gt; OM\n    OM -. \"Returns\" .-&gt; HK</code></pre>"},{"location":"dev/design/branch-hooks/overview/#when-activated-in-fast-mode","title":"When Activated in 'Fast Mode'","text":"<p>'Fast Mode' is an optimisation that inserts the jmp to point directly into your code when possible.</p> <pre><code>flowchart TD\n    CF[Caller Function]\n    HK[\"&amp;lt;Your Function&amp;gt;\"]\n    OM[Original Method]\n\n    CF -- \"call 'Your Function' instead of original\" --&gt; HK\n    HK -. \"Calls &amp;lt;Optionally&amp;gt;\" .-&gt; OM\n    OM -. \"Returns\" .-&gt; HK</code></pre> <p>This option allows for a small performance improvement, saving 1 instruction and some instruction prefetching load. </p> <p>This is on by default (can be disabled), and will take into effect when no conversion between calling conventions is needed.</p>"},{"location":"dev/design/branch-hooks/overview/#when-activated-with-calling-convention-conversion","title":"When Activated (with Calling Convention Conversion)","text":"<pre><code>flowchart TD\n    CF[Caller Function]\n    RW[ReverseWrapper]\n    HK[\"&amp;lt;Your Function&amp;gt;\"]\n    W[Wrapper]\n    OM[Original Method]\n\n    CF -- \"call wrapper\" --&gt; RW\n    RW -- jump to your code --&gt; HK\n    HK -. \"Calls &amp;lt;Optionally&amp;gt;\" .-&gt; W\n    W -- \"call original (wrapped)\" --&gt; OM\n    OM -. \"Returns\" .-&gt; W\n    W -. \"Returns\" .-&gt; HK</code></pre>"},{"location":"dev/design/branch-hooks/overview/#when-deactivated","title":"When Deactivated","text":"<pre><code>flowchart TD\n    CF[Caller Function]\n    SB[Stub]\n    HK[Hook Function]\n    OM[Original Method]\n\n    CF -- jump to stub --&gt; SB\n    SB -- jump to original --&gt; OM</code></pre> <p>When the hook is deactivated, the stub is replaced with a direct jump back to the original function.</p> <p>By bypassing your code entirely, it is safe for your dynamic library (<code>.dll</code>/<code>.so</code>/<code>.dylib</code>)  to unload from the process.</p>"},{"location":"dev/design/branch-hooks/overview/#thread-safety-memory-layout-state-switching","title":"Thread Safety, Memory Layout &amp; State Switching","text":"<p>Common: Thread Safety &amp; Memory Layout</p>"},{"location":"dev/design/branch-hooks/overview/#stub-memory-layout","title":"Stub Memory Layout","text":"<p>The 'branch hook' stub uses the following memory layout:</p> <pre><code>- [Branch to Hook Function / Branch to Original Function]\n- Branch to Hook Function\n- Branch to Original Function\n</code></pre> <p>If calling convention conversion is needed, the layout looks like this:</p> <pre><code>- [ReverseWrapper / Branch to Original Function]\n- ReverseWrapper\n- Branch to Original Function\n- Wrapper\n</code></pre> <p>The library is optimised to not use redundant memory</p> <p>For example, in x86 (32-bit), a <code>jmp</code> instruction can reach any address from any address. In that situation, we don't write <code>Branch to Original Function</code> to the buffer at all, provided a <code>ReverseWrapper</code> is not needed, as it is not necessary.</p>"},{"location":"dev/design/branch-hooks/overview/#examples","title":"Examples","text":"<p>Using x86 Assembly.</p>"},{"location":"dev/design/branch-hooks/overview/#before","title":"Before","text":"<pre><code>originalCaller:\n; Some code...\ncall originalFunction\n; More code...\n</code></pre>"},{"location":"dev/design/branch-hooks/overview/#after-fast-mode","title":"After (Fast Mode)","text":"<pre><code>originalCaller:\n; Some code...\ncall userFunction ; To user method\n; More code...\n\nuserFunction:\n; New function implementation...\ncall originalFunction ; Optional.\n</code></pre>"},{"location":"dev/design/branch-hooks/overview/#after","title":"After","text":"<pre><code>; x86 Assembly\noriginalCaller:\n; Some code...\ncall stub\n; More code...\n\nstub:\n; == BranchToHook ==\njmp newFunction\n; == BranchToHook ==\n\n; == BranchToOriginal ==\njmp originalFunction\n; == BranchToOriginal ==\n\nnewFunction:\n; New function implementation...\ncall originalFunction ; Optional.\n</code></pre>"},{"location":"dev/design/branch-hooks/overview/#after-with-calling-convention-conversion","title":"After (with Calling Convention Conversion)","text":"<pre><code>; x86 Assembly\noriginalCaller:\n; Some code...\ncall stub\n; More code...\n\nstub:\n; == ReverseWrapper ==\n; implementation..\ncall userFunction\n; ..implementation\n; == ReverseWrapper ==\n\n; == Wrapper ==\n; implementation ..\njmp originalFunction\n; .. implementation\n; == Wrapper ==\n\n; == BranchToOriginal ==\njmp originalFunction ; Whenever disabled :wink:\n; == BranchToOriginal ==\n\nuserFunction:\n; New function implementation...\ncall wrapper; (See Above)\n</code></pre>"},{"location":"dev/design/branch-hooks/overview/#after-disabled","title":"After (Disabled)","text":"<pre><code>; x86 Assembly\noriginalCaller:\n; Some code...\ncall stub\n; More code...\n\nstub:\n&lt;jmp to `jmp originalFunction`&gt; ; We disable the hook by branching to instruction that branches to original\njmp originalFunction ; Whenever disabled :wink:\n\nnewFunction:\n; New function implementation...\ncall originalFunction ; Optional.\n\noriginalFunction:\n; Original function implementation...\n</code></pre>"},{"location":"dev/design/function-hooks/hooking-strategy-arm64/","title":"Interoperability (ARM64)","text":"<p>Please read the general section first, this contains ARM64 specific stuff.</p>"},{"location":"dev/design/function-hooks/hooking-strategy-arm64/#fallback-strategy-free-space-from-function-alignment","title":"Fallback Strategy: Free Space from Function Alignment","text":"<p>See General Section Notes.</p> <p>In the case of ARM64, padding is usually down with the following sequences: - <code>nop</code> (<code>0xD503201F</code>, big endian), used by GCC. - <code>and x0, x0</code> (<code>0x00000000</code>), used by MSVC.  </p> <p>Getting sufficient bytes to make good use of them in ARM64 is more uncommon than x86.</p>"},{"location":"dev/design/function-hooks/hooking-strategy-x86/","title":"Interoperability (x86)","text":"<p>Please read the general section first, this contains x86 specific stuff.</p>"},{"location":"dev/design/function-hooks/hooking-strategy-x86/#fallback-strategy-free-space-from-function-alignment","title":"Fallback Strategy: Free Space from Function Alignment","text":"<p>See General Section Notes.</p> <ul> <li>x86 programs align instructions on 16 byte boundaries. </li> <li>Bytes <code>0x90</code> (GCC) or <code>0xCC</code> (MSVC) are commonly used for padding.</li> </ul>"},{"location":"dev/design/function-hooks/hooking-strategy-x86/#fallback-strategy-return-address-patching","title":"Fallback Strategy: Return Address Patching","text":"<p>See General Section Notes.</p> <p>We use x86 in the example for general section above.</p>"},{"location":"dev/design/function-hooks/hooking-strategy/","title":"Interoperability (General)","text":"<p>This page just contains common information regarding interoperability that are common to all platforms.</p> <p>Interpoerability in this sense means 'stacking hooks ontop of other libraries', and how other libraries can stack hooks ontop of <code>reloaded-hooks-rs</code>.</p>"},{"location":"dev/design/function-hooks/hooking-strategy/#general-hooking-strategy","title":"General Hooking Strategy","text":"<p>This is the general hooking strategy employed by <code>reloaded-hooks</code>; derived from the facts in the rest of this document.</p> <p>To ensure maximum compatibility with existing hooking systems, <code>reloaded-hooks</code> uses  relative jumps as these are the most popular, and thus best supported by other libraries when it comes to hook stacking.  </p> <p>These are the lowest overhead jumps, so are preferable in any case. </p>"},{"location":"dev/design/function-hooks/hooking-strategy/#if-relative-jump-is-not-possible","title":"If Relative Jump is Not Possible","text":"<p>In the very, very, unlikely event that using (target is further than  <code>max relative jump distance</code>), the following strategy below is used.</p>"},{"location":"dev/design/function-hooks/hooking-strategy/#no-existing-hook","title":"No Existing Hook","text":"<p>If no existing hook exists, an absolute jump will be used (if possible). - Prefer indirect absolute jump (if possible).  </p> <p>We check for presence of 'existing hook' by catching some common instruction patterns.</p>"},{"location":"dev/design/function-hooks/hooking-strategy/#existing-hook","title":"Existing Hook","text":"<ul> <li> <p>If we have any allocated buffer in range, insert relative jump,    and inside wrapper/stub use absolute jump if needed.  </p> <ul> <li>This prevents your hook longer than original error case.  </li> </ul> </li> <li> <p>Otherwise (if possible), use available free space from function alignment.  </p> <ul> <li>If supported IP Relative Jmp, with target address in free space.  </li> <li>Otherwise try store whole absolute jump, in said alignment space.</li> </ul> </li> <li> <p>Otherwise use absolute jump.</p> <ul> <li>And attempt return address patching, if this is ever re-implemented into library.  </li> </ul> </li> </ul>"},{"location":"dev/design/function-hooks/hooking-strategy/#calling-back-into-original-function","title":"Calling Back into Original Function","text":"<p>In order to optimize the code relocation process, <code>reloaded-hooks</code>,  will try to find a buffer that's within relative jump range to the original jump target.</p> <p>If this is not possible, <code>reloaded-hooks</code> will start rewriting relative jump(s)  from the original function to absolute jump(s) in the presence of recognised patterns; if the code rewriter supports this.</p>"},{"location":"dev/design/function-hooks/hooking-strategy/#fallback-strategies","title":"Fallback Strategies","text":"<p>Strategies used for improving interoperability with other hooks.</p>"},{"location":"dev/design/function-hooks/hooking-strategy/#free-space-from-function-alignment","title":"Free Space from Function Alignment","text":"<p>This is a strategy for encoding absolute jumps using fewer instructions.</p> <p>Processors typically fetch instructions 16 byte boundaries.</p> <p>To optimise for this, compilers pad the space between end of last function and start of next.</p> <p>We can exploit this \ud83d\ude09</p> <p>If there's sufficient padding before the function, we can: - Insert our absolute jump there, and branch to it. or - Insert jump target there, and branch using that jump target.  </p>"},{"location":"dev/design/function-hooks/overview/","title":"Function Hooks","text":"<p>How hooking around entire functions works.</p> <p>This hook is used to run custom callback for a function, modify its parameters or replace a function entirely. It is the most common hook.</p> <p>I'm not a security person/researcher. I just make full stack game modding tools, mods and libraries. Naming in these design docs might be unconventional.</p> <p>This hook works by injecting a <code>jmp</code> instruction at the beginning of a function to a custom  replacement function, or a stub which will later call that function. </p> <p>When the original function is called, it is done via a wrapper, which restores the originally  overwritten instructions that were sacrificed for the <code>jmp</code>.</p>"},{"location":"dev/design/function-hooks/overview/#high-level-diagram","title":"High Level Diagram","text":""},{"location":"dev/design/function-hooks/overview/#key","title":"Key","text":"<ul> <li><code>Stolen Bytes</code>: Bytes used by instructions sacrificed in original function to place a 'jmp' to the <code>ReverseWrapper</code>.  </li> <li><code>ReverseWrapper</code>: Translates from original function calling convention to yours. Then calls your function.  </li> <li><code>&lt;Your Function&gt;</code>: Your Rust/C#/C++/Asm code.  </li> <li><code>Wrapper</code>: Translates from your calling convention to original, then runs the original function.  </li> </ul>"},{"location":"dev/design/function-hooks/overview/#when-activated","title":"When Activated","text":"<pre><code>flowchart TD\n    orig[Original Function] -- jump to wrapper --&gt; rev[Reverse Wrapper]\n    rev -- jump to your code --&gt; target[\"&amp;lt;Your Function&amp;gt;\"]\n    target -- \"call original via wrapper\" --&gt; stub[\"Wrapper &amp;lt;with stolen bytes + jmp to original&amp;gt;\"]\n    stub -- \"call original\" --&gt; original[\"Original Function\"]\n\n    original -- \"return value\" --&gt; stub\n    stub -- \"return value\" --&gt; target</code></pre> <p>When the hook is activated, a stub calls into your function; which becomes the 'new original function'; that is, control will return (<code>ret</code>) to the original function's caller from this function.</p> <p>When your function calls the original function, it will be an entirely separate method call.</p> <p>Your function can technically not call the original and replace it outright.</p>"},{"location":"dev/design/function-hooks/overview/#when-activated-in-fast-mode","title":"When Activated in 'Fast Mode'","text":"<p>'Fast Mode' is an optimisation that inserts the <code>jmp</code> to point directly into your code when possible.</p> <pre><code>flowchart TD\n    orig[Original Function] -- to your code --&gt; target[\"&amp;lt;Your Function&amp;gt;\"]\n    target -- \"call original via wrapper\" --&gt; stub[\"Wrapper &amp;lt;with stolen bytes + jmp to original&amp;gt;\"]\n    stub -- \"call original\" --&gt; original[\"Original Function\"]\n\n    original -- \"return value\" --&gt; stub\n    stub -- \"return value\" --&gt; target</code></pre> <p>This option allows for a small performance improvement, saving 1 instruction and some instruction prefetching load.  </p> <p>This is on by default (can be disabled), and will take into effect when no conversion between calling conventions is needed.  </p> <p>When conversion is needed, the logic will default back to When Activated.  </p> <p>When 'Fast Mode' is enabled, you lose the ability to unhook (for compatibility reasons).</p>"},{"location":"dev/design/function-hooks/overview/#when-deactivated","title":"When Deactivated","text":"<p>Does not apply to 'Fast Mode'. When in fast mode, deactivation returns error.</p> <pre><code>flowchart TD\n    orig[Original Function] -- jump to wrapper --&gt; stub[\"Stub &amp;lt;stolen bytes + jmp&amp;gt;\"]\n    stub -- \"jmp original\" --&gt; original[\"Original Function\"]</code></pre> <p>When you deactivate a hook, the contents of 'Reverse Wrapper' are overwritten with the stolen bytes.  </p> <p>When 'Reverse Wrapper' is allocated, extra space is reserved for original code.</p> <p>By bypassing your code entirely, it is safe for your dynamic library (<code>.dll</code>/<code>.so</code>/<code>.dylib</code>)  to unload from the process.</p>"},{"location":"dev/design/function-hooks/overview/#calling-convention-inference","title":"Calling Convention Inference","text":"<p>It is recommended library users manually specify conventions in their hook functions.\"</p> <p>When the calling convention of <code>&lt;your function&gt;</code> is not specified, wrapper libraries must insert the appropriate default convention in their wrappers.</p> <p>On Linux, syscalls use R10 instead of RCX in SystemV ABI</p>"},{"location":"dev/design/function-hooks/overview/#rust","title":"Rust","text":"<ul> <li><code>i686-pc-windows-gnu</code>: cdecl</li> <li><code>i686-pc-windows-msvc</code>: cdecl</li> <li> <p><code>i686-unknown-linux-gnu</code>: SystemV (x86)</p> </li> <li> <p><code>x86_64-pc-windows-gnu</code>: Microsoft x64</p> </li> <li><code>x86_64-pc-windows-msvc</code>: Microsoft x64</li> <li><code>x86_64-unknown-linux-gnu</code>: SystemV (x64)</li> <li><code>x86_64-apple-darwin</code>: SystemV (x64)</li> </ul>"},{"location":"dev/design/function-hooks/overview/#c","title":"C","text":"<ul> <li><code>Windows x86</code>: cdecl</li> <li> <p><code>Windows x64</code>: Microsoft x64</p> </li> <li> <p><code>Linux x64</code>: SystemV (x64)</p> </li> <li> <p><code>Linux x86</code>: SystemV (x86)</p> </li> <li> <p><code>macOS x64</code>: SystemV (x64)</p> </li> </ul>"},{"location":"dev/design/function-hooks/overview/#wrappers","title":"Wrapper(s)","text":"<p>Wrappers are stubs which convert from the calling convention of the original function to your calling convention.</p> <p>If the calling convention of the hooked function and your function matches, this wrapper is simply just 1 <code>jmp</code> instruction.</p> <p>Wrappers are documented in their own page here.</p>"},{"location":"dev/design/function-hooks/overview/#reversewrappers","title":"ReverseWrapper(s)","text":"<p>Stub which converts from your code's calling convention to original function's calling convention</p> <p>This is basically Wrapper with <code>source</code> and <code>destination</code> swapped around</p>"},{"location":"dev/design/vtable-hooks/overview/","title":"VTable Hooks","text":"<p>Replaces a pointer inside an array of function pointers with a new pointer.</p> <p>This hook is commonly used to hook <code>COM</code> objects, e.g. <code>Direct3D</code>.</p> <p>I'm not a security person/researcher. I just make full stack game modding tools, mods and libraries. Naming in these design docs might be unconventional.</p> <p>Probably the simplest hook out of them all, it's simply replacing one pointer inside an array of function pointers with a new one.</p>"},{"location":"dev/design/vtable-hooks/overview/#about-vtables","title":"About VTables","text":"<p>VTables, are what is used to support polymorphism in C++ and similar languages.</p> <p>They are the mechanism that enables calling correct functions in presence of inheritance and virtual functions.</p> <p>Basically what drives 'interfaces' in other languages.</p>"},{"location":"dev/design/vtable-hooks/overview/#vtables-in-msvc-gcc","title":"VTables in MSVC &amp; GCC","text":"<p>In both GCC and Visual C++, VTables are automatically created for classes that have virtual functions. </p> <p>They are located at offset 0x0 of any class, thus if you get a pointer to a class, and dereference offset 0x0, you'll be at the address of the first item in the VTable.</p> C++Memory Layout <pre><code>class Item {\nvirtual void doSomething();\nint k;\n};\n</code></pre> <pre><code>class Item\n    void* vTable\n    int k\n</code></pre> <pre><code>vTable:\n    void* doSomething\n</code></pre> <p>VTables exist in <code>.rdata</code>, thus you need to change memory permissions when hooking them.</p>"},{"location":"dev/design/vtable-hooks/overview/#vtables-in-com-objects","title":"VTables in COM Objects","text":"<p>One notable thing about COM is that all interfaces inherit from IUnknown, so the first 4 methods will always be the 4 methods of <code>IUnknown</code>.</p>"},{"location":"dev/design/vtable-hooks/overview/#high-level-diagram","title":"High Level Diagram","text":"<p>Using Direct3D9 as an example</p>"},{"location":"dev/design/vtable-hooks/overview/#before","title":"Before","text":"<pre><code>flowchart LR\n    EndScene --&gt; EndScene_Orig \n    Clear --&gt; Clear_Orig\n    SetTransform --&gt; SetTransform_Orig\n    GetTransform  --&gt; GetTransform_Orig</code></pre>"},{"location":"dev/design/vtable-hooks/overview/#after","title":"After","text":"<pre><code>flowchart LR\n    EndScene --&gt; EndScene_Hook --&gt; Your_Function --&gt; EndScene_Orig\n    Clear --&gt; Clear_Orig\n    SetTransform --&gt; SetTransform_Orig\n    GetTransform  --&gt; GetTransform_Orig</code></pre>"},{"location":"dev/platform/overview/","title":"Platform Overview","text":"<p>This page provides a list of platform specific functionality required for supporting <code>Reloaded.Hooks-rs</code>.</p> <ul> <li><code>Required</code> means library must have this to function.  </li> <li><code>Recommended</code> means library may not work on some edge cases.  </li> <li><code>Optional</code> means library can function without it.  </li> </ul> <p>To add support for new platforms, supply the necessary function pointers in <code>platform_functions.rs</code>.</p> Feature Windows Linux macOS Permission Change \u2705 \u2705 \u2705 W^X Disable/Restore N/A N/A [1] \u26a0\ufe0f [2] Targeted Memory Allocation \u2705 \u2705 \u2705 <p>[1] May be present depending on kernel configuration. Have not done adequate research. [2] Needed for Apple Silicon only.</p>"},{"location":"dev/platform/overview/#how-to-implement-support","title":"How to Implement Support","text":"<p>Once you're done, submit a PR to add support for your platform.</p>"},{"location":"dev/platform/overview/#platform-functions","title":"Platform Functions","text":"<p>The library provides a <code>platform_functions.rs</code> file which contains all the platform specific functions.</p> <p>Implement the functions in this file for your platform. Generally you'll only need <code>unprotect_memory</code>,  though on some platforms, you may need to implement <code>disable_write_xor_execute</code> and <code>restore_write_xor_execute</code>  as well, depending on the platform's security policy.</p>"},{"location":"dev/platform/overview/#recommended-buffers-implementation","title":"(Recommended) Buffers Implementation","text":"<p>For optimal performance, you should add support for your platform to reloaded-memory-buffers.</p> <p>It's recommended to use <code>reloaded-hooks-rs</code> alongside <code>reloaded-memory-buffers</code>. The concept of the buffers library is to perform allocations as close to original code as possible, allowing for more efficient code.</p> <p>This requires walking memory pages. If your OS does not have a way to do this, you can in the meantime use the built-in <code>DefaultBufferFactory</code>. On some platforms you'll also need to adjust <code>DefaultBufferFactory::create_page_as_rx</code>,  if your platform does not allow RWX allocations.</p> <p>For <code>DefaultBufferFactory</code>, you might need to replace <code>mmap_rs</code> in <code>get_any_buffer</code> to use your platform specific page allocation function.</p>"},{"location":"dev/platform/overview/#testing-your-implementation","title":"Testing Your Implementation","text":"<p>Platform specific functionality is not unit tested as it relies on OS/system state. Instead, integration  tests are used to test the functionality.</p> <p>Find the tests for a given hook type (recommend: <code>assembly_hook</code> tests) and run them on your platform.  </p> <p>If you can't run tests on your platform, copy them to one of your programs manually.  </p>"},{"location":"dev/platform/overview/#required-permission-change","title":"(Required) Permission Change","text":"<p>Many platforms have per-page access permissions; which may prevent certain regions of memory from being modified.</p> <p>Notably for the use cases of this library, the <code>.text</code> section is usually non-writeable, which  prevents hooking app functions out of the box.  </p> <p>To work around this, the library will call the <code>unprotect</code> function in <code>platform_functions.rs</code> before  making code changes in memory. It will then (for performance reasons) leave the memory unprotected  for the lifetime of the process (assuming it remains unprotected).</p> <p>For the common operating systems; the <code>protect</code>/<code>unprotect</code> functions map to the following API calls:  </p> <ul> <li>Windows: <code>VirtualProtect</code> </li> <li>Linux &amp; macOS: <code>mprotect</code> </li> </ul>"},{"location":"dev/platform/overview/#required-wx-disablerestore","title":"(Required) W^X Disable/Restore","text":"<p>Only required on Apple, opt in on Linux/Windows but haven't used in a game software in the wild.</p> <p>Info</p> <p>Some platforms enforce a security protection called 'Write XOR Execute'; where a memory page may only be marked as writeable OR executable at any moment in time.</p> <ul> <li>Relevant Issue for macOS M1</li> </ul> <p>To work around this, the library will call the <code>disable_write_xor_execute</code> function in <code>platform_functions.rs</code>  ahead of every function call. It will then call <code>restore_write_xor_execute</code> after.</p>"},{"location":"dev/platform/overview/#recommended-targeted-memory-allocation","title":"(Recommended) Targeted Memory Allocation","text":"<p>Info</p> <p>The process of code relocation might require that new location of the code is within a certain region of the old code, usually 128MiB, 2GiB or 4GiB (depending on platform).</p> <p>In this case, you must walk over the memory pages of a process; and find a suitable place to allocate \ud83d\ude09</p>"}]}